#!/bin/bash
#===============================================================================
# Loki Mode CLI Wrapper (v5.0.0)
# Simple command-line interface for Loki Mode
#
# Installation:
#   ln -sf ~/.claude/skills/loki-mode/autonomy/loki /usr/local/bin/loki
#
# Usage:
#   loki start [PRD]      - Start Loki Mode (optionally with PRD)
#   loki stop             - Stop execution immediately
#   loki pause            - Pause after current session
#   loki resume           - Resume paused execution
#   loki status           - Show current status
#   loki dashboard        - Open dashboard in browser
#   loki import           - Import GitHub issues
#   loki help             - Show this help
#===============================================================================

set -euo pipefail

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
BOLD='\033[1m'
DIM='\033[2m'
NC='\033[0m'

# Resolve the script's real path (handles symlinks)
resolve_script_path() {
    local script="$1"
    # Use realpath if available, otherwise fall back to readlink
    if command -v realpath &> /dev/null; then
        realpath "$script" 2>/dev/null || echo "$script"
    elif command -v readlink &> /dev/null; then
        # macOS readlink doesn't have -f, use a loop
        while [ -L "$script" ]; do
            local dir=$(dirname "$script")
            script=$(readlink "$script")
            [[ "$script" != /* ]] && script="$dir/$script"
        done
        echo "$script"
    else
        echo "$script"
    fi
}

# Find the skill installation
find_skill_dir() {
    local script_path
    script_path=$(resolve_script_path "$0")
    local script_dir
    script_dir=$(dirname "$script_path")

    local dirs=(
        "$HOME/.claude/skills/loki-mode"
        "$script_dir/.."
        "."
    )

    for dir in "${dirs[@]}"; do
        if [ -f "$dir/SKILL.md" ] && [ -f "$dir/autonomy/run.sh" ]; then
            echo "$dir"
            return 0
        fi
    done

    echo ""
    return 1
}

# Use || true to prevent set -e from exiting before error message
SKILL_DIR=$(find_skill_dir) || true
if [ -z "$SKILL_DIR" ]; then
    # Check if installation exists but is incomplete (missing run.sh)
    _check_dir1="$HOME/.claude/skills/loki-mode"
    _check_dir2="$(dirname "$(resolve_script_path "$0")")/.."
    _incomplete_install=""

    for _dir in "$_check_dir1" "$_check_dir2"; do
        if [ -f "$_dir/SKILL.md" ] && [ ! -f "$_dir/autonomy/run.sh" ]; then
            _incomplete_install="$_dir"
            break
        fi
    done

    if [ -n "$_incomplete_install" ]; then
        echo -e "${RED}Error: Loki Mode installation is incomplete${NC}"
        echo "Missing: $_incomplete_install/autonomy/run.sh"
        echo ""
        echo -e "${YELLOW}Fix with:${NC}"
        echo "  npm uninstall -g loki-mode && npm install -g loki-mode"
        echo ""
        echo "This can happen when npm cache is corrupted."
    else
        echo -e "${RED}Error: Could not find Loki Mode installation${NC}"
        echo "Expected at: ~/.claude/skills/loki-mode"
        echo "Or install via: npm install -g loki-mode"
    fi
    exit 1
fi

RUN_SH="$SKILL_DIR/autonomy/run.sh"
SANDBOX_SH="$SKILL_DIR/autonomy/sandbox.sh"
LOKI_DIR=".loki"

# Get version from VERSION file
get_version() {
    if [ -f "$SKILL_DIR/VERSION" ]; then
        cat "$SKILL_DIR/VERSION"
    else
        echo "unknown"
    fi
}

# Show help
show_help() {
    local version=$(get_version)
    echo -e "${BOLD}Loki Mode v$version${NC}"
    echo ""
    echo "Usage: loki <command> [options]"
    echo ""
    echo "Commands:"
    echo "  start [PRD]      Start Loki Mode (optionally with PRD file)"
    echo "  stop             Stop execution immediately"
    echo "  pause            Pause after current session"
    echo "  resume           Resume paused execution"
    echo "  status           Show current status"
    echo "  logs             Show recent log output"
    echo "  dashboard        Open dashboard in browser"
    echo "  provider [cmd]   Manage AI provider (show|set|list|info)"
    echo "  serve            Start HTTP API server (alias for api start)"
    echo "  api [cmd]        HTTP API server (start|stop|status)"
    echo "  sandbox [cmd]    Docker sandbox (start|stop|status|logs|shell|build)"
    echo "  import           Import GitHub issues as tasks"
    echo "  config [cmd]     Manage configuration (show|init|edit|path)"
    echo "  memory [cmd]     Cross-project learnings (list|show|search|stats)"
    echo "  reset [target]   Reset session state (all|retries|failed)"
    echo "  version          Show version"
    echo "  help             Show this help"
    echo ""
    echo "Options for 'start':"
    echo "  --provider NAME  AI provider: claude (default), codex, gemini"
    echo "  --parallel       Enable parallel mode with git worktrees"
    echo "  --bg, --background  Run in background mode"
    echo "  --simple         Force simple complexity tier (3 phases)"
    echo "  --complex        Force complex complexity tier (8 phases)"
    echo "  --github         Enable GitHub issue import"
    echo "  --no-dashboard   Disable web dashboard"
    echo "  --sandbox        Run in Docker sandbox for isolation"
    echo ""
    echo "Examples:"
    echo "  loki start                    # Start in current directory"
    echo "  loki start ./prd.md           # Start with PRD file"
    echo "  loki start --bg               # Start in background"
    echo "  loki start --parallel         # Start in parallel mode"
    echo "  loki pause                    # Pause execution"
    echo "  loki status                   # Check current status"
    echo ""
    echo "Environment Variables:"
    echo "  See: $RUN_SH (header comments)"
}

# Start Loki Mode
cmd_start() {
    local args=()
    local prd_file=""
    local provider=""

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --help|-h)
                echo -e "${BOLD}loki start${NC} - Start Loki Mode autonomous execution"
                echo ""
                echo "Usage: loki start [PRD] [options]"
                echo ""
                echo "Arguments:"
                echo "  PRD                   Path to PRD file (optional)"
                echo ""
                echo "Options:"
                echo "  --provider NAME       AI provider: claude (default), codex, gemini"
                echo "  --parallel            Enable parallel mode with git worktrees"
                echo "  --bg, --background    Run in background mode"
                echo "  --simple              Force simple complexity tier (3 phases)"
                echo "  --complex             Force complex complexity tier (8 phases)"
                echo "  --github              Enable GitHub issue import"
                echo "  --no-dashboard        Disable web dashboard"
                echo "  --sandbox             Run in Docker sandbox"
                echo ""
                echo "Examples:"
                echo "  loki start                      # Interactive or resume existing"
                echo "  loki start ./prd.md             # Start with PRD file"
                echo "  loki start ./prd.md --parallel  # Parallel mode with worktrees"
                echo "  loki start --provider codex     # Use OpenAI Codex CLI"
                exit 0
                ;;
            --provider)
                if [[ -n "${2:-}" ]]; then
                    provider="$2"
                    args+=("--provider" "$provider")
                    shift 2
                else
                    echo -e "${RED}--provider requires a value (claude, codex, gemini)${NC}"
                    exit 1
                fi
                ;;
            --provider=*)
                provider="${1#*=}"
                args+=("--provider" "$provider")
                shift
                ;;
            --parallel)
                args+=("--parallel")
                shift
                ;;
            --bg|--background)
                args+=("--bg")
                shift
                ;;
            --simple)
                export LOKI_COMPLEXITY=simple
                shift
                ;;
            --complex)
                export LOKI_COMPLEXITY=complex
                shift
                ;;
            --github)
                export LOKI_GITHUB_IMPORT=true
                shift
                ;;
            --no-dashboard)
                export LOKI_DASHBOARD=false
                shift
                ;;
            --sandbox)
                export LOKI_SANDBOX_MODE=true
                shift
                ;;
            -*)
                echo -e "${RED}Unknown option: $1${NC}"
                exit 1
                ;;
            *)
                prd_file="$1"
                shift
                ;;
        esac
    done

    if [ -n "$prd_file" ]; then
        args+=("$prd_file")
    fi

    # Load saved provider if not specified on command line
    if [ -z "$provider" ]; then
        if [ -f "$LOKI_DIR/state/provider" ]; then
            provider=$(cat "$LOKI_DIR/state/provider" 2>/dev/null)
            if [ -n "$provider" ]; then
                args+=("--provider" "$provider")
            fi
        fi
    fi

    # Determine effective provider for display
    local effective_provider="${provider:-${LOKI_PROVIDER:-claude}}"

    # Handle sandbox mode - delegate to sandbox.sh
    if [[ "${LOKI_SANDBOX_MODE:-}" == "true" ]]; then
        if [ ! -f "$SANDBOX_SH" ]; then
            echo -e "${RED}Error: sandbox.sh not found at $SANDBOX_SH${NC}"
            exit 1
        fi

        # Check Docker availability
        if ! command -v docker &> /dev/null; then
            echo -e "${RED}Error: Docker not found${NC}"
            echo ""
            echo "Docker is required for sandbox mode. Install it:"
            echo "  macOS:  brew install --cask docker"
            echo "  Linux:  curl -fsSL https://get.docker.com | sh"
            exit 1
        fi

        if ! docker info &> /dev/null 2>&1; then
            echo -e "${RED}Error: Docker daemon not running${NC}"
            echo ""
            echo "Start Docker:"
            echo "  macOS:  Open Docker Desktop app"
            echo "  Linux:  sudo systemctl start docker"
            exit 1
        fi

        echo -e "${GREEN}Starting Loki Mode in Docker sandbox...${NC}"
        exec "$SANDBOX_SH" start "${args[@]}"
    fi

    # Show provider info
    echo -e "${GREEN}Starting Loki Mode...${NC}"
    echo -e "${CYAN}Provider:${NC} $effective_provider"
    if [ -f "$LOKI_DIR/state/provider" ]; then
        echo -e "${DIM}  (saved for this project - change with: loki provider set <name>)${NC}"
    else
        echo -e "${DIM}  (default - save for project with: loki provider set <name>)${NC}"
    fi
    echo ""

    exec "$RUN_SH" "${args[@]}"
}

# Check if session is running
is_session_running() {
    if [ -f "$LOKI_DIR/run.pid" ]; then
        local pid
        pid=$(cat "$LOKI_DIR/run.pid" 2>/dev/null)
        if [ -n "$pid" ] && kill -0 "$pid" 2>/dev/null; then
            return 0
        fi
    fi
    return 1
}

# Stop execution immediately
cmd_stop() {
    if [ ! -d "$LOKI_DIR" ]; then
        echo -e "${YELLOW}No .loki directory found.${NC}"
        echo "No active session to stop."
        exit 0
    fi

    if is_session_running; then
        touch "$LOKI_DIR/STOP"
        echo -e "${RED}STOP signal sent. Execution will halt immediately.${NC}"
    else
        echo -e "${YELLOW}No active session running.${NC}"
        if [ -f "$LOKI_DIR/STOP" ]; then
            echo "STOP signal already present."
        else
            echo "Start a session with: loki start"
        fi
    fi
}

# Pause after current session
cmd_pause() {
    if [ ! -d "$LOKI_DIR" ]; then
        echo -e "${YELLOW}No .loki directory found.${NC}"
        echo "No active session to pause."
        exit 0
    fi

    if is_session_running; then
        touch "$LOKI_DIR/PAUSE"
        echo -e "${YELLOW}PAUSE signal sent. Execution will pause after current task.${NC}"
        echo -e "${DIM}Resume with: loki resume${NC}"
    else
        echo -e "${YELLOW}No active session running.${NC}"
        if [ -f "$LOKI_DIR/PAUSE" ]; then
            echo "PAUSE signal already present."
        else
            echo "Start a session with: loki start"
        fi
    fi
}

# Resume paused execution
cmd_resume() {
    if [ ! -d "$LOKI_DIR" ]; then
        echo -e "${YELLOW}No .loki directory found.${NC}"
        echo "Nothing to resume. Start a session with: loki start"
        exit 0
    fi

    local removed_signal=""
    if [ -f "$LOKI_DIR/PAUSE" ]; then
        rm -f "$LOKI_DIR/PAUSE"
        removed_signal="PAUSE"
    elif [ -f "$LOKI_DIR/STOP" ]; then
        rm -f "$LOKI_DIR/STOP"
        removed_signal="STOP"
    fi

    if [ -n "$removed_signal" ]; then
        if is_session_running; then
            echo -e "${GREEN}$removed_signal signal cleared. Session will resume automatically.${NC}"
        else
            echo -e "${GREEN}$removed_signal signal cleared.${NC}"
            echo "Session is not running. Start with: loki start"
        fi
    else
        if is_session_running; then
            echo -e "${CYAN}Session is running normally.${NC}"
        else
            echo -e "${YELLOW}No pause/stop signals found.${NC}"
            echo "Session is not running. Start with: loki start"
        fi
    fi
}

# Show current status
cmd_status() {
    if [ ! -d "$LOKI_DIR" ]; then
        echo -e "${YELLOW}No .loki directory found.${NC}"
        echo "Loki Mode has not been initialized in this directory."
        exit 0
    fi

    echo -e "${BOLD}Loki Mode Status${NC}"
    echo ""

    # Show current provider
    local saved_provider=""
    if [ -f "$LOKI_DIR/state/provider" ]; then
        saved_provider=$(cat "$LOKI_DIR/state/provider" 2>/dev/null)
    fi
    local current_provider="${saved_provider:-${LOKI_PROVIDER:-claude}}"
    # Show provider with capability
    local capability="full features"
    case "$current_provider" in
        codex|gemini)
            capability="degraded mode"
            ;;
    esac
    echo -e "${CYAN}Provider:${NC} $current_provider ($capability)"
    echo -e "${DIM}  Switch with: loki provider set <claude|codex|gemini>${NC}"
    echo ""

    # Check for signals first (more prominent)
    if [ -f "$LOKI_DIR/PAUSE" ]; then
        echo -e "${YELLOW}Status: PAUSED${NC}"
        echo -e "${DIM}  Resume with: loki resume${NC}"
        echo ""
    elif [ -f "$LOKI_DIR/STOP" ]; then
        echo -e "${RED}Status: STOPPED${NC}"
        echo -e "${DIM}  Clear with: loki resume${NC}"
        echo ""
    fi

    # Check status file
    if [ -f "$LOKI_DIR/STATUS.txt" ]; then
        echo -e "${CYAN}Session Info:${NC}"
        cat "$LOKI_DIR/STATUS.txt"
        echo ""
    fi

    # Check orchestrator state
    if [ -f "$LOKI_DIR/state/orchestrator.json" ]; then
        echo -e "${CYAN}Orchestrator State:${NC}"
        jq -r '.currentPhase // "unknown"' "$LOKI_DIR/state/orchestrator.json" 2>/dev/null || echo "unknown"
    fi

    # Check pending tasks
    if [ -f "$LOKI_DIR/queue/pending.json" ]; then
        local task_count=$(jq '.tasks | length' "$LOKI_DIR/queue/pending.json" 2>/dev/null || echo "0")
        echo -e "${CYAN}Pending Tasks:${NC} $task_count"
    fi

    # Check dashboard
    if [ -f "$LOKI_DIR/dashboard/index.html" ]; then
        local port=${LOKI_DASHBOARD_PORT:-57374}
        echo -e "${CYAN}Dashboard:${NC} http://127.0.0.1:$port/dashboard/index.html"
    fi
}

# Provider management
cmd_provider() {
    local subcommand="${1:-show}"
    shift || true

    case "$subcommand" in
        show|current)
            cmd_provider_show
            ;;
        set)
            cmd_provider_set "$@"
            ;;
        list)
            cmd_provider_list
            ;;
        info)
            cmd_provider_info "$@"
            ;;
        *)
            echo -e "${BOLD}Loki Mode Provider Management${NC}"
            echo ""
            echo "Usage: loki provider <command>"
            echo ""
            echo "Commands:"
            echo "  show     Show current provider (default)"
            echo "  set      Set provider for this project"
            echo "  list     List available providers"
            echo "  info     Show provider details"
            echo ""
            echo "Examples:"
            echo "  loki provider show"
            echo "  loki provider set claude"
            echo "  loki provider set codex"
            echo "  loki provider list"
            echo "  loki provider info gemini"
            ;;
    esac
}

cmd_provider_show() {
    local saved_provider=""
    if [ -f "$LOKI_DIR/state/provider" ]; then
        saved_provider=$(cat "$LOKI_DIR/state/provider" 2>/dev/null)
    fi

    local current="${saved_provider:-${LOKI_PROVIDER:-claude}}"

    echo -e "${BOLD}Current Provider${NC}"
    echo ""
    echo -e "${CYAN}Provider:${NC} $current"

    # Show capability status
    case "$current" in
        claude)
            echo -e "${GREEN}Status:${NC}   Full features (subagents, parallel, MCP)"
            ;;
        codex|gemini)
            echo -e "${YELLOW}Status:${NC}   Degraded mode (sequential only)"
            ;;
    esac

    if [ -n "$saved_provider" ]; then
        echo -e "${DIM}(saved in .loki/state/provider)${NC}"
    else
        echo -e "${DIM}(default - not explicitly set)${NC}"
    fi

    echo ""
    echo -e "Switch provider: ${CYAN}loki provider set <name>${NC}"
    echo -e "Available:       ${CYAN}loki provider list${NC}"
}

cmd_provider_set() {
    local new_provider="${1:-}"

    if [ -z "$new_provider" ]; then
        echo -e "${RED}Error: Provider name required${NC}"
        echo "Usage: loki provider set <claude|codex|gemini>"
        exit 1
    fi

    # Validate provider
    case "$new_provider" in
        claude|codex|gemini)
            ;;
        *)
            echo -e "${RED}Error: Invalid provider '$new_provider'${NC}"
            echo "Valid providers: claude, codex, gemini"
            exit 1
            ;;
    esac

    # Check if CLI is installed
    if ! command -v "$new_provider" &> /dev/null; then
        echo -e "${YELLOW}Warning: '$new_provider' CLI not found in PATH${NC}"
        echo ""
        case "$new_provider" in
            claude)
                echo "Install: npm install -g @anthropic-ai/claude-code"
                ;;
            codex)
                echo "Install: npm install -g @openai/codex"
                ;;
            gemini)
                echo "Install: npm install -g @anthropic-ai/gemini-cli"
                ;;
        esac
        echo ""
        echo -e "${DIM}Setting provider anyway...${NC}"
    fi

    # Save provider
    mkdir -p "$LOKI_DIR/state"
    echo "$new_provider" > "$LOKI_DIR/state/provider"

    echo -e "${GREEN}Provider set to: $new_provider${NC}"
    echo ""
    echo "This will be used for all future runs in this project."
    echo "Override temporarily with: loki start --provider <name>"
}

cmd_provider_list() {
    echo -e "${BOLD}Available Providers${NC}"
    echo ""

    local saved_provider=""
    if [ -f "$LOKI_DIR/state/provider" ]; then
        saved_provider=$(cat "$LOKI_DIR/state/provider" 2>/dev/null)
    fi
    local current="${saved_provider:-${LOKI_PROVIDER:-claude}}"

    # Check which CLIs are installed
    local claude_status="${RED}not installed${NC}"
    local codex_status="${RED}not installed${NC}"
    local gemini_status="${RED}not installed${NC}"

    if command -v claude &> /dev/null; then
        claude_status="${GREEN}installed${NC}"
    fi
    if command -v codex &> /dev/null; then
        codex_status="${GREEN}installed${NC}"
    fi
    if command -v gemini &> /dev/null; then
        gemini_status="${GREEN}installed${NC}"
    fi

    # Display providers
    local marker=""
    [ "$current" = "claude" ] && marker=" ${CYAN}(current)${NC}"
    echo -e "  claude  - Claude Code (Anthropic)     $claude_status$marker"

    marker=""
    [ "$current" = "codex" ] && marker=" ${CYAN}(current)${NC}"
    echo -e "  codex   - Codex CLI (OpenAI)          $codex_status$marker"

    marker=""
    [ "$current" = "gemini" ] && marker=" ${CYAN}(current)${NC}"
    echo -e "  gemini  - Gemini CLI (Google)         $gemini_status$marker"

    echo ""
    echo -e "Set provider: ${CYAN}loki provider set <name>${NC}"
}

cmd_provider_info() {
    local provider="${1:-${LOKI_PROVIDER:-claude}}"

    echo -e "${BOLD}Provider: $provider${NC}"
    echo ""

    case "$provider" in
        claude)
            echo "Name:        Claude Code"
            echo "Vendor:      Anthropic"
            echo "CLI:         claude"
            echo "Flag:        --dangerously-skip-permissions"
            echo ""
            echo "Features:"
            echo "  - Full autonomous mode"
            echo "  - Task tool for subagents"
            echo "  - Parallel execution"
            echo "  - MCP server support"
            echo ""
            echo "Status:      Full features"
            ;;
        codex)
            echo "Name:        Codex CLI"
            echo "Vendor:      OpenAI"
            echo "CLI:         codex"
            echo "Flag:        exec --dangerously-bypass-approvals-and-sandbox"
            echo ""
            echo "Features:"
            echo "  - Autonomous mode"
            echo "  - Sequential only (no subagents)"
            echo ""
            echo "Status:      Degraded mode"
            ;;
        gemini)
            echo "Name:        Gemini CLI"
            echo "Vendor:      Google"
            echo "CLI:         gemini"
            echo "Flag:        --yolo"
            echo ""
            echo "Features:"
            echo "  - Autonomous mode"
            echo "  - Sequential only (no subagents)"
            echo ""
            echo "Status:      Degraded mode"
            ;;
        *)
            echo -e "${RED}Unknown provider: $provider${NC}"
            exit 1
            ;;
    esac
}

# Open dashboard in browser
cmd_dashboard() {
    local port=${LOKI_DASHBOARD_PORT:-57374}
    local url="http://127.0.0.1:$port/dashboard/index.html"

    if [ ! -d "$LOKI_DIR/dashboard" ]; then
        echo -e "${YELLOW}Dashboard not found. Start Loki Mode first.${NC}"
        exit 1
    fi

    echo -e "${GREEN}Opening dashboard: $url${NC}"

    # Open in browser (cross-platform)
    if command -v open &> /dev/null; then
        open "$url"
    elif command -v xdg-open &> /dev/null; then
        xdg-open "$url"
    else
        echo "Please open in browser: $url"
    fi
}

# Import GitHub issues
cmd_import() {
    if [ ! -d "$LOKI_DIR" ]; then
        mkdir -p "$LOKI_DIR/queue"
    fi

    export LOKI_GITHUB_IMPORT=true

    # Check gh CLI
    if ! command -v gh &> /dev/null; then
        echo -e "${RED}Error: gh CLI not found. Install with: brew install gh${NC}"
        exit 1
    fi

    if ! gh auth status &> /dev/null; then
        echo -e "${RED}Error: gh CLI not authenticated. Run: gh auth login${NC}"
        exit 1
    fi

    echo -e "${GREEN}Importing GitHub issues...${NC}"
    # Source the functions from run.sh and call import
    source "$RUN_SH" 2>/dev/null || true
    if type import_github_issues &>/dev/null; then
        import_github_issues
    else
        echo -e "${YELLOW}Import function not available. Using fallback.${NC}"
        gh issue list --json number,title,url --limit 20
    fi
}

# Show configuration
cmd_config() {
    local subcommand="${1:-show}"

    case "$subcommand" in
        show)
            cmd_config_show
            ;;
        init)
            cmd_config_init
            ;;
        edit)
            cmd_config_edit
            ;;
        path)
            cmd_config_path
            ;;
        *)
            echo -e "${YELLOW}Usage: loki config [show|init|edit|path]${NC}"
            echo ""
            echo "  show   Show current configuration (default)"
            echo "  init   Create a config file from template"
            echo "  edit   Open config file in editor"
            echo "  path   Show config file paths"
            ;;
    esac
}

cmd_config_show() {
    echo -e "${BOLD}Loki Mode Configuration${NC}"
    echo ""
    echo -e "${CYAN}Installation:${NC} $SKILL_DIR"
    echo -e "${CYAN}Version:${NC} $(get_version)"
    echo ""

    # Check for config files
    local config_file=""
    if [ -f ".loki/config.yaml" ]; then
        config_file=".loki/config.yaml"
        echo -e "${GREEN}Config file:${NC} $config_file (project-local)"
    elif [ -f ".loki/config.yml" ]; then
        config_file=".loki/config.yml"
        echo -e "${GREEN}Config file:${NC} $config_file (project-local)"
    elif [ -f "${HOME}/.config/loki-mode/config.yaml" ]; then
        config_file="${HOME}/.config/loki-mode/config.yaml"
        echo -e "${GREEN}Config file:${NC} $config_file (user-global)"
    elif [ -f "${HOME}/.config/loki-mode/config.yml" ]; then
        config_file="${HOME}/.config/loki-mode/config.yml"
        echo -e "${GREEN}Config file:${NC} $config_file (user-global)"
    else
        echo -e "${YELLOW}Config file:${NC} Not found (using defaults)"
    fi
    echo ""

    echo -e "${CYAN}Current Settings:${NC}"
    echo ""
    echo "Core:"
    echo "  max_retries:      ${LOKI_MAX_RETRIES:-50}"
    echo "  base_wait:        ${LOKI_BASE_WAIT:-60}s"
    echo "  max_wait:         ${LOKI_MAX_WAIT:-3600}s"
    echo ""
    echo "Dashboard:"
    echo "  enabled:          ${LOKI_DASHBOARD:-true}"
    echo "  port:             ${LOKI_DASHBOARD_PORT:-57374}"
    echo ""
    echo "Notifications:"
    echo "  enabled:          ${LOKI_NOTIFICATIONS:-true}"
    echo "  sound:            ${LOKI_NOTIFICATION_SOUND:-true}"
    echo ""
    echo "GitHub Integration:"
    echo "  import:           ${LOKI_GITHUB_IMPORT:-false}"
    echo "  pr:               ${LOKI_GITHUB_PR:-false}"
    echo "  sync:             ${LOKI_GITHUB_SYNC:-false}"
    echo ""
    echo "Provider:"
    echo "  provider:         ${LOKI_PROVIDER:-claude}"
    echo ""
    echo "Execution:"
    echo "  complexity:       ${LOKI_COMPLEXITY:-auto}"
    echo "  parallel_mode:    ${LOKI_PARALLEL_MODE:-false}"
    echo "  max_iterations:   ${LOKI_MAX_ITERATIONS:-1000}"
    echo "  autonomy_mode:    ${LOKI_AUTONOMY_MODE:-perpetual}"
    echo ""
    echo -e "Run ${CYAN}loki config path${NC} to see all config file locations"
}

cmd_config_init() {
    local template="$SKILL_DIR/autonomy/config.example.yaml"
    local target=".loki/config.yaml"
    local global_target="${HOME}/.config/loki-mode/config.yaml"

    if [ ! -f "$template" ]; then
        echo -e "${RED}Error: Config template not found at $template${NC}"
        exit 1
    fi

    echo -e "${BOLD}Initialize Configuration${NC}"
    echo ""
    echo "Where do you want to create the config file?"
    echo ""
    echo "  1) $target (project-local, recommended)"
    echo "  2) $global_target (user-global)"
    echo ""
    read -p "Choice [1]: " choice
    choice="${choice:-1}"

    case "$choice" in
        1)
            mkdir -p ".loki"
            cp "$template" "$target"
            echo -e "${GREEN}Created: $target${NC}"
            ;;
        2)
            mkdir -p "${HOME}/.config/loki-mode"
            cp "$template" "$global_target"
            echo -e "${GREEN}Created: $global_target${NC}"
            ;;
        *)
            echo -e "${RED}Invalid choice${NC}"
            exit 1
            ;;
    esac

    echo ""
    echo "Edit with: loki config edit"
}

cmd_config_edit() {
    local config_file=""

    # Find existing config file
    if [ -f ".loki/config.yaml" ]; then
        config_file=".loki/config.yaml"
    elif [ -f ".loki/config.yml" ]; then
        config_file=".loki/config.yml"
    elif [ -f "${HOME}/.config/loki-mode/config.yaml" ]; then
        config_file="${HOME}/.config/loki-mode/config.yaml"
    elif [ -f "${HOME}/.config/loki-mode/config.yml" ]; then
        config_file="${HOME}/.config/loki-mode/config.yml"
    fi

    if [ -z "$config_file" ]; then
        echo -e "${YELLOW}No config file found.${NC}"
        read -p "Create one? [Y/n]: " create
        create="${create:-Y}"
        if [[ "$create" =~ ^[Yy] ]]; then
            cmd_config_init
            config_file=".loki/config.yaml"
        else
            exit 0
        fi
    fi

    # Open in editor
    local editor="${EDITOR:-${VISUAL:-vim}}"
    echo -e "${GREEN}Opening $config_file with $editor${NC}"
    "$editor" "$config_file"
}

cmd_config_path() {
    echo -e "${BOLD}Config File Search Paths${NC}"
    echo ""
    echo "Loki Mode searches for config files in this order:"
    echo ""

    local paths=(
        ".loki/config.yaml"
        ".loki/config.yml"
        "${HOME}/.config/loki-mode/config.yaml"
        "${HOME}/.config/loki-mode/config.yml"
    )

    for path in "${paths[@]}"; do
        if [ -f "$path" ]; then
            echo -e "  ${GREEN}[FOUND]${NC}  $path"
        else
            echo -e "  ${YELLOW}[-----]${NC}  $path"
        fi
    done

    echo ""
    echo "Template: $SKILL_DIR/autonomy/config.example.yaml"
    echo ""
    echo "Create a config file with: loki config init"
}

# Show version
cmd_version() {
    echo "Loki Mode v$(get_version)"
}

# Show recent logs
cmd_logs() {
    local lines="${1:-50}"
    local log_file="$LOKI_DIR/logs/session.log"

    if [ ! -f "$log_file" ]; then
        echo -e "${YELLOW}No log file found at $log_file${NC}"
        exit 0
    fi

    echo -e "${BOLD}Recent Logs (last $lines lines)${NC}"
    echo ""
    tail -n "$lines" "$log_file"
}

# API server management
cmd_api() {
    local subcommand="${1:-help}"
    local port="${LOKI_API_PORT:-9898}"
    local pid_file="$LOKI_DIR/api.pid"
    local api_server="$SKILL_DIR/api/server.js"

    case "$subcommand" in
        start)
            # Check if Node.js is available
            if ! command -v node &> /dev/null; then
                echo -e "${RED}Error: Node.js not found. Install with: brew install node${NC}"
                exit 1
            fi

            # Check if already running
            if [ -f "$pid_file" ]; then
                local existing_pid=$(cat "$pid_file")
                if kill -0 "$existing_pid" 2>/dev/null; then
                    echo -e "${YELLOW}API server already running (PID: $existing_pid)${NC}"
                    echo "URL: http://localhost:$port"
                    exit 0
                fi
            fi

            # Start server
            mkdir -p "$LOKI_DIR"
            nohup node "$api_server" --port "$port" > "$LOKI_DIR/logs/api.log" 2>&1 &
            local new_pid=$!
            echo "$new_pid" > "$pid_file"

            echo -e "${GREEN}API server started${NC}"
            echo "  PID:  $new_pid"
            echo "  URL:  http://localhost:$port"
            echo "  Logs: $LOKI_DIR/logs/api.log"
            ;;

        stop)
            if [ -f "$pid_file" ]; then
                local pid=$(cat "$pid_file")
                if kill -0 "$pid" 2>/dev/null; then
                    kill "$pid"
                    rm -f "$pid_file"
                    echo -e "${GREEN}API server stopped${NC}"
                else
                    rm -f "$pid_file"
                    echo -e "${YELLOW}API server was not running${NC}"
                fi
            else
                echo -e "${YELLOW}No API server PID file found${NC}"
            fi
            ;;

        status)
            if [ -f "$pid_file" ]; then
                local pid=$(cat "$pid_file")
                if kill -0 "$pid" 2>/dev/null; then
                    echo -e "${GREEN}API server running${NC}"
                    echo "  PID:  $pid"
                    echo "  URL:  http://localhost:$port"

                    # Try to fetch status
                    if command -v curl &> /dev/null; then
                        echo ""
                        echo -e "${CYAN}Status:${NC}"
                        curl -s "http://localhost:$port/status" 2>/dev/null | jq . 2>/dev/null || true
                    fi
                else
                    echo -e "${YELLOW}API server not running (stale PID file)${NC}"
                    rm -f "$pid_file"
                fi
            else
                echo -e "${YELLOW}API server not running${NC}"
            fi
            ;;

        *)
            echo -e "${BOLD}Loki Mode API Server${NC}"
            echo ""
            echo "Usage: loki api <command>"
            echo ""
            echo "Commands:"
            echo "  start    Start the HTTP API server"
            echo "  stop     Stop the API server"
            echo "  status   Check if API server is running"
            echo ""
            echo "Environment:"
            echo "  LOKI_API_PORT  Port to listen on (default: 9898)"
            echo ""
            echo "Endpoints:"
            echo "  GET  /health  - Health check"
            echo "  GET  /status  - Session status"
            echo "  GET  /events  - SSE stream"
            echo "  GET  /logs    - Recent logs"
            echo "  POST /start   - Start session"
            echo "  POST /stop    - Stop session"
            echo "  POST /pause   - Pause session"
            echo "  POST /resume  - Resume session"
            ;;
    esac
}

# Sandbox management (delegates to sandbox.sh)
cmd_sandbox() {
    local subcommand="${1:-help}"
    shift || true

    if [ ! -f "$SANDBOX_SH" ]; then
        echo -e "${RED}Error: sandbox.sh not found at $SANDBOX_SH${NC}"
        echo "Expected at: $SKILL_DIR/autonomy/sandbox.sh"
        exit 1
    fi

    # Check Docker availability
    if ! command -v docker &> /dev/null; then
        echo -e "${RED}Error: Docker not found${NC}"
        echo ""
        echo "Docker is required for sandbox mode. Install it:"
        echo "  macOS:  brew install --cask docker"
        echo "  Linux:  curl -fsSL https://get.docker.com | sh"
        echo ""
        echo "After installation, start Docker Desktop or the Docker daemon."
        exit 1
    fi

    if ! docker info &> /dev/null 2>&1; then
        echo -e "${RED}Error: Docker daemon not running${NC}"
        echo ""
        echo "Start Docker:"
        echo "  macOS:  Open Docker Desktop app"
        echo "  Linux:  sudo systemctl start docker"
        exit 1
    fi

    # Delegate to sandbox.sh
    exec "$SANDBOX_SH" "$subcommand" "$@"
}

# Main command dispatcher
main() {
    if [ $# -eq 0 ]; then
        show_help
        exit 0
    fi

    local command="$1"
    shift

    case "$command" in
        start)
            cmd_start "$@"
            ;;
        stop)
            cmd_stop
            ;;
        pause)
            cmd_pause
            ;;
        resume)
            cmd_resume
            ;;
        status)
            cmd_status
            ;;
        dashboard)
            cmd_dashboard
            ;;
        logs)
            cmd_logs "$@"
            ;;
        serve)
            cmd_api start "$@"
            ;;
        api)
            cmd_api "$@"
            ;;
        sandbox)
            cmd_sandbox "$@"
            ;;
        import)
            cmd_import
            ;;
        config)
            cmd_config "$@"
            ;;
        provider)
            cmd_provider "$@"
            ;;
        reset)
            cmd_reset "$@"
            ;;
        memory)
            cmd_memory "$@"
            ;;
        version|--version|-v)
            cmd_version
            ;;
        help|--help|-h)
            show_help
            ;;
        *)
            echo -e "${RED}Unknown command: $command${NC}"
            echo "Run 'loki help' for usage."
            exit 1
            ;;
    esac
}

# Reset session state
cmd_reset() {
    local subcommand="${1:-all}"

    case "$subcommand" in
        retries|retry)
            if [ -f "$LOKI_DIR/autonomy-state.json" ]; then
                # Reset only retry count
                if command -v python3 &> /dev/null; then
                    python3 -c "
import json
with open('$LOKI_DIR/autonomy-state.json', 'r') as f:
    state = json.load(f)
state['retryCount'] = 0
state['status'] = 'reset'
with open('$LOKI_DIR/autonomy-state.json', 'w') as f:
    json.dump(state, f, indent=4)
" 2>/dev/null
                    echo -e "${GREEN}Retry count reset to 0${NC}"
                else
                    rm -f "$LOKI_DIR/autonomy-state.json"
                    echo -e "${GREEN}Autonomy state cleared${NC}"
                fi
            else
                echo -e "${YELLOW}No autonomy state found${NC}"
            fi
            ;;
        failed|failures)
            if [ -f "$LOKI_DIR/queue/failed.json" ]; then
                local count
                count=$(jq 'length' "$LOKI_DIR/queue/failed.json" 2>/dev/null || echo "?")
                rm -f "$LOKI_DIR/queue/failed.json"
                echo "[]" > "$LOKI_DIR/queue/failed.json"
                echo -e "${GREEN}Cleared $count failed tasks${NC}"
            else
                echo -e "${YELLOW}No failed tasks found${NC}"
            fi
            ;;
        all)
            # Reset everything
            rm -f "$LOKI_DIR/autonomy-state.json"
            echo "[]" > "$LOKI_DIR/queue/failed.json" 2>/dev/null
            echo -e "${GREEN}Session state reset${NC}"
            echo "  - Autonomy state cleared"
            echo "  - Failed task queue cleared"
            ;;
        --help|-h|help)
            echo -e "${BOLD}loki reset${NC} - Reset session state"
            echo ""
            echo "Usage: loki reset [target]"
            echo ""
            echo "Targets:"
            echo "  all       Reset everything (default)"
            echo "  retries   Reset only the retry counter"
            echo "  failed    Clear failed task queue"
            echo ""
            echo "Examples:"
            echo "  loki reset              # Reset all state"
            echo "  loki reset retries      # Just reset retry count"
            echo "  loki reset failed       # Clear failed tasks"
            ;;
        *)
            echo -e "${RED}Unknown reset target: $subcommand${NC}"
            echo "Valid targets: all, retries, failed"
            exit 1
            ;;
    esac
}

# Cross-project memory/learnings management
cmd_memory() {
    local subcommand="${1:-list}"
    local learnings_dir="${HOME}/.loki/learnings"

    # Ensure directory exists
    mkdir -p "$learnings_dir"

    case "$subcommand" in
        list|ls)
            echo -e "${BOLD}Cross-Project Learnings${NC}"
            echo ""

            local patterns=0 mistakes=0 successes=0
            [ -f "$learnings_dir/patterns.jsonl" ] && patterns=$(grep -c '"description"' "$learnings_dir/patterns.jsonl" 2>/dev/null) || patterns=0
            [ -f "$learnings_dir/mistakes.jsonl" ] && mistakes=$(grep -c '"description"' "$learnings_dir/mistakes.jsonl" 2>/dev/null) || mistakes=0
            [ -f "$learnings_dir/successes.jsonl" ] && successes=$(grep -c '"description"' "$learnings_dir/successes.jsonl" 2>/dev/null) || successes=0

            echo -e "  Patterns:  ${GREEN}$patterns${NC}"
            echo -e "  Mistakes:  ${YELLOW}$mistakes${NC}"
            echo -e "  Successes: ${CYAN}$successes${NC}"
            echo ""
            echo "Location: $learnings_dir"
            echo ""
            echo "Use 'loki memory show <type>' to view entries"
            ;;

        show)
            # Parse arguments: show <type> [--limit N] [--project P]
            local type="${2:-all}"
            local limit=20
            local project=""
            shift 2 2>/dev/null || true

            while [[ $# -gt 0 ]]; do
                case "$1" in
                    --limit|-l)
                        limit="${2:-20}"
                        shift 2
                        ;;
                    --project|-p)
                        project="${2:-}"
                        shift 2
                        ;;
                    *)
                        shift
                        ;;
                esac
            done

            case "$type" in
                patterns|pattern)
                    echo -e "${BOLD}Patterns${NC}"
                    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
                    if [ -f "$learnings_dir/patterns.jsonl" ]; then
                        python3 -c "
import json
limit = $limit
project_filter = '$project'
count = 0
with open('$learnings_dir/patterns.jsonl', 'r') as f:
    for line in f:
        if count >= limit:
            break
        try:
            e = json.loads(line)
            if 'description' in e:
                if project_filter and e.get('project', '') != project_filter:
                    continue
                print(f\"[{e.get('project', 'unknown')}] {e['description'][:100]}\")
                count += 1
        except: pass
if count == 0:
    print('(empty - no patterns recorded)')
" 2>/dev/null
                    else
                        echo "(empty - no patterns recorded)"
                    fi
                    ;;

                mistakes|mistake)
                    echo -e "${BOLD}Mistakes${NC}"
                    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
                    if [ -f "$learnings_dir/mistakes.jsonl" ]; then
                        python3 -c "
import json
limit = $limit
project_filter = '$project'
count = 0
with open('$learnings_dir/mistakes.jsonl', 'r') as f:
    for line in f:
        if count >= limit:
            break
        try:
            e = json.loads(line)
            if 'description' in e:
                if project_filter and e.get('project', '') != project_filter:
                    continue
                print(f\"[{e.get('project', 'unknown')}] {e['description'][:100]}\")
                count += 1
        except: pass
if count == 0:
    print('(empty - no mistakes recorded)')
" 2>/dev/null
                    else
                        echo "(empty - no mistakes recorded)"
                    fi
                    ;;

                successes|success)
                    echo -e "${BOLD}Successes${NC}"
                    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
                    if [ -f "$learnings_dir/successes.jsonl" ]; then
                        python3 -c "
import json
limit = $limit
project_filter = '$project'
count = 0
with open('$learnings_dir/successes.jsonl', 'r') as f:
    for line in f:
        if count >= limit:
            break
        try:
            e = json.loads(line)
            if 'description' in e:
                if project_filter and e.get('project', '') != project_filter:
                    continue
                print(f\"[{e.get('project', 'unknown')}] {e['description'][:100]}\")
                count += 1
        except: pass
if count == 0:
    print('(empty - no successes recorded)')
" 2>/dev/null
                    else
                        echo "(empty - no successes recorded)"
                    fi
                    ;;

                all)
                    cmd_memory show patterns --limit "$limit"
                    echo ""
                    cmd_memory show mistakes --limit "$limit"
                    echo ""
                    cmd_memory show successes --limit "$limit"
                    ;;

                *)
                    echo -e "${RED}Unknown type: $type${NC}"
                    echo "Valid types: patterns, mistakes, successes, all"
                    exit 1
                    ;;
            esac
            ;;

        search)
            local query="${2:-}"
            if [ -z "$query" ]; then
                echo -e "${RED}Usage: loki memory search <query>${NC}"
                exit 1
            fi

            echo -e "${BOLD}Search Results for: $query${NC}"
            echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"

            python3 -c "
import json
import os

learnings_dir = '$learnings_dir'
query = '$query'.lower()

for filename in ['patterns.jsonl', 'mistakes.jsonl', 'successes.jsonl']:
    filepath = os.path.join(learnings_dir, filename)
    if not os.path.exists(filepath):
        continue

    category = filename.replace('.jsonl', '')
    with open(filepath, 'r') as f:
        for line in f:
            try:
                e = json.loads(line)
                desc = e.get('description', '').lower()
                if query in desc:
                    print(f\"[{category}] [{e.get('project', 'unknown')}] {e['description'][:80]}...\")
            except: pass
" 2>/dev/null
            ;;

        clear)
            local type="${2:-}"

            if [ -z "$type" ]; then
                echo -e "${YELLOW}This will delete ALL cross-project learnings.${NC}"
                echo -n "Are you sure? (yes/no): "
                read -r confirm
                if [ "$confirm" = "yes" ]; then
                    rm -rf "$learnings_dir"
                    mkdir -p "$learnings_dir"
                    echo '{"version":"1.0","created":"'"$(date -u +%Y-%m-%dT%H:%M:%SZ)"'"}' > "$learnings_dir/patterns.jsonl"
                    echo '{"version":"1.0","created":"'"$(date -u +%Y-%m-%dT%H:%M:%SZ)"'"}' > "$learnings_dir/mistakes.jsonl"
                    echo '{"version":"1.0","created":"'"$(date -u +%Y-%m-%dT%H:%M:%SZ)"'"}' > "$learnings_dir/successes.jsonl"
                    echo -e "${GREEN}All learnings cleared${NC}"
                else
                    echo "Cancelled"
                fi
            else
                case "$type" in
                    patterns|mistakes|successes)
                        echo '{"version":"1.0","created":"'"$(date -u +%Y-%m-%dT%H:%M:%SZ)"'"}' > "$learnings_dir/${type}.jsonl"
                        echo -e "${GREEN}Cleared $type${NC}"
                        ;;
                    *)
                        echo -e "${RED}Unknown type: $type${NC}"
                        echo "Valid types: patterns, mistakes, successes"
                        exit 1
                        ;;
                esac
            fi
            ;;

        export)
            local output="${2:-learnings-export.json}"

            python3 -c "
import json
import os

learnings_dir = '$learnings_dir'
result = {'patterns': [], 'mistakes': [], 'successes': []}

for category in ['patterns', 'mistakes', 'successes']:
    filepath = os.path.join(learnings_dir, f'{category}.jsonl')
    if os.path.exists(filepath):
        with open(filepath, 'r') as f:
            for line in f:
                try:
                    e = json.loads(line)
                    if 'description' in e:
                        result[category].append(e)
                except: pass

with open('$output', 'w') as f:
    json.dump(result, f, indent=2)
print(f'Exported to $output')
" 2>/dev/null
            ;;

        stats)
            echo -e "${BOLD}Learning Statistics${NC}"
            echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"

            python3 -c "
import json
import os
from collections import Counter

learnings_dir = '$learnings_dir'
projects = Counter()
categories = Counter()

for filename in ['patterns.jsonl', 'mistakes.jsonl', 'successes.jsonl']:
    filepath = os.path.join(learnings_dir, filename)
    if not os.path.exists(filepath):
        continue

    category = filename.replace('.jsonl', '')
    with open(filepath, 'r') as f:
        for line in f:
            try:
                e = json.loads(line)
                if 'description' in e:
                    projects[e.get('project', 'unknown')] += 1
                    categories[category] += 1
            except: pass

print('By Category:')
for cat, count in categories.most_common():
    print(f'  {cat}: {count}')

print()
print('By Project:')
for proj, count in projects.most_common(10):
    print(f'  {proj}: {count}')
" 2>/dev/null
            ;;

        dedupe|dedup)
            echo -e "${BOLD}Deduplicating Learnings${NC}"
            echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"

            python3 -c "
import json
import os
import hashlib
from datetime import datetime, timezone

learnings_dir = '$learnings_dir'

def dedupe_file(filepath):
    '''Deduplicate a JSONL file, keeping first occurrence of each unique description'''
    if not os.path.exists(filepath):
        return 0, 0

    seen_hashes = set()
    unique_entries = []
    duplicates = 0

    # Read all entries
    with open(filepath, 'r') as f:
        for line in f:
            try:
                entry = json.loads(line)
                if 'description' not in entry:
                    # Keep header/metadata lines
                    if 'version' in entry:
                        unique_entries.append(entry)
                    continue

                # Normalize description for hashing (case-insensitive, trimmed)
                desc = entry['description'].strip().lower()
                h = hashlib.md5(desc.encode()).hexdigest()

                if h not in seen_hashes:
                    seen_hashes.add(h)
                    unique_entries.append(entry)
                else:
                    duplicates += 1
            except json.JSONDecodeError:
                continue

    # Write back unique entries
    with open(filepath, 'w') as f:
        for entry in unique_entries:
            f.write(json.dumps(entry) + '\n')

    return len(unique_entries) - (1 if unique_entries and 'version' in unique_entries[0] else 0), duplicates

total_kept = 0
total_removed = 0

for category in ['patterns', 'mistakes', 'successes']:
    filepath = os.path.join(learnings_dir, f'{category}.jsonl')
    kept, removed = dedupe_file(filepath)
    total_kept += kept
    total_removed += removed
    if removed > 0:
        print(f'{category}: kept {kept}, removed {removed} duplicates')
    else:
        print(f'{category}: {kept} entries (no duplicates)')

print()
print(f'Total: kept {total_kept} unique entries, removed {total_removed} duplicates')
if total_removed > 0:
    reduction = total_removed / (total_kept + total_removed) * 100
    print(f'Storage reduced by {reduction:.1f}%')
" 2>/dev/null
            ;;

        --help|-h|help)
            echo -e "${BOLD}loki memory${NC} - Manage cross-project learnings"
            echo ""
            echo "Usage: loki memory <command> [args]"
            echo ""
            echo "Commands:"
            echo "  list              Show summary of all learnings"
            echo "  show [type]       Show entries (patterns|mistakes|successes|all)"
            echo "                    Options: --limit N, --project P"
            echo "  search <query>    Search across all learnings"
            echo "  stats             Show statistics by project and category"
            echo "  export [file]     Export to JSON file"
            echo "  dedupe            Remove duplicate entries"
            echo "  clear [type]      Clear learnings (all or specific type)"
            echo ""
            echo "Examples:"
            echo "  loki memory list"
            echo "  loki memory show mistakes --limit 10"
            echo "  loki memory show patterns --project myapp"
            echo "  loki memory search 'rate limit'"
            echo "  loki memory dedupe"
            echo "  loki memory export backup.json"
            ;;

        *)
            echo -e "${RED}Unknown memory command: $subcommand${NC}"
            echo "Run 'loki memory help' for usage."
            exit 1
            ;;
    esac
}

main "$@"
