#!/bin/bash
#===============================================================================
# Loki Mode CLI Wrapper
# Command-line interface for Loki Mode
#
# Installation:
#   ln -sf ~/.claude/skills/loki-mode/autonomy/loki /usr/local/bin/loki
#
# Usage:
#   loki start [PRD]      - Start Loki Mode (optionally with PRD)
#   loki stop             - Stop execution immediately
#   loki pause            - Pause after current session
#   loki resume           - Resume paused execution
#   loki status           - Show current status
#   loki dashboard        - Open dashboard in browser
#   loki import           - Import GitHub issues
#   loki github [cmd]     - GitHub integration (sync|export|pr|status)
#   loki help             - Show this help
#===============================================================================

set -euo pipefail

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
BOLD='\033[1m'
DIM='\033[2m'
NC='\033[0m'

# Resolve the script's real path (handles symlinks)
resolve_script_path() {
    local script="$1"
    # Use realpath if available, otherwise fall back to readlink
    if command -v realpath &> /dev/null; then
        realpath "$script" 2>/dev/null || echo "$script"
    elif command -v readlink &> /dev/null; then
        # macOS readlink doesn't have -f, use a loop
        while [ -L "$script" ]; do
            local dir=$(dirname "$script")
            script=$(readlink "$script")
            [[ "$script" != /* ]] && script="$dir/$script"
        done
        echo "$script"
    else
        echo "$script"
    fi
}

# Find the skill installation
find_skill_dir() {
    local script_path
    script_path=$(resolve_script_path "$0")
    local script_dir
    script_dir=$(dirname "$script_path")

    # Check script's own parent first (most likely current), then installed skill, then cwd
    local script_parent
    script_parent="$(cd "$script_dir/.." 2>/dev/null && pwd)"
    local dirs=(
        "$script_parent"
        "$HOME/.claude/skills/loki-mode"
        "."
    )

    for dir in "${dirs[@]}"; do
        if [ -f "$dir/SKILL.md" ] && [ -f "$dir/autonomy/run.sh" ]; then
            echo "$dir"
            return 0
        fi
    done

    echo ""
    return 1
}

# Use || true to prevent set -e from exiting before error message
SKILL_DIR=$(find_skill_dir) || true
if [ -z "$SKILL_DIR" ]; then
    # Check if installation exists but is incomplete (missing run.sh)
    _check_dir1="$HOME/.claude/skills/loki-mode"
    _check_dir2="$(dirname "$(resolve_script_path "$0")")/.."
    _incomplete_install=""

    for _dir in "$_check_dir1" "$_check_dir2"; do
        if [ -f "$_dir/SKILL.md" ] && [ ! -f "$_dir/autonomy/run.sh" ]; then
            _incomplete_install="$_dir"
            break
        fi
    done

    if [ -n "$_incomplete_install" ]; then
        echo -e "${RED}Error: Loki Mode installation is incomplete${NC}"
        echo "Missing: $_incomplete_install/autonomy/run.sh"
        echo ""
        echo -e "${YELLOW}Fix with:${NC}"
        echo "  npm uninstall -g loki-mode && npm install -g loki-mode"
        echo ""
        echo "This can happen when npm cache is corrupted."
    else
        echo -e "${RED}Error: Could not find Loki Mode installation${NC}"
        echo "Expected at: ~/.claude/skills/loki-mode"
        echo "Or install via: npm install -g loki-mode"
    fi
    exit 1
fi

RUN_SH="$SKILL_DIR/autonomy/run.sh"
SANDBOX_SH="$SKILL_DIR/autonomy/sandbox.sh"
EMIT_SH="$SKILL_DIR/events/emit.sh"
LEARNING_EMIT_SH="$SKILL_DIR/learning/emit.sh"
LOKI_DIR=".loki"

# Anonymous usage telemetry
PROJECT_DIR="$SKILL_DIR"
_TELEMETRY_SCRIPT="$SKILL_DIR/autonomy/telemetry.sh"
if [ -f "$_TELEMETRY_SCRIPT" ]; then
    source "$_TELEMETRY_SCRIPT"
fi

# Get version from VERSION file
get_version() {
    if [ -f "$SKILL_DIR/VERSION" ]; then
        cat "$SKILL_DIR/VERSION"
    else
        echo "unknown"
    fi
}

# Check if jq is available (called by functions that need it)
require_jq() {
    if ! command -v jq &> /dev/null; then
        echo -e "${RED}Error: jq is required but not installed.${NC}"
        echo "Install with:"
        echo "  brew install jq    (macOS)"
        echo "  apt install jq     (Debian/Ubuntu)"
        echo "  yum install jq     (RHEL/CentOS)"
        exit 1
    fi
}

# Emit event (non-blocking)
# Usage: emit_event <type> <source> <action> [key=value ...]
emit_event() {
    if [ -f "$EMIT_SH" ]; then
        # Run in background to be non-blocking
        ("$EMIT_SH" "$@" >/dev/null 2>&1 &)
    fi
}

# Emit learning signal (non-blocking) - SYN-018
# Usage: emit_learning_signal <signal_type> [options]
# Signal types: user_preference, error_pattern, success_pattern, tool_efficiency, workflow_pattern
# See learning/emit.sh for full option documentation
emit_learning_signal() {
    if [ -f "$LEARNING_EMIT_SH" ]; then
        # Run in background to be non-blocking
        (LOKI_DIR="$LOKI_DIR" LOKI_SKILL_DIR="$SKILL_DIR" "$LEARNING_EMIT_SH" "$@" >/dev/null 2>&1 &)
    fi
}

# Track session timing for efficiency signals
SESSION_START_TIME=""
record_session_start() {
    SESSION_START_TIME=$(date +%s%3N 2>/dev/null || echo $(($(date +%s) * 1000)))
}

# Calculate session duration in milliseconds
get_session_duration_ms() {
    if [ -n "$SESSION_START_TIME" ]; then
        local end_time
        end_time=$(date +%s%3N 2>/dev/null || echo $(($(date +%s) * 1000)))
        echo $((end_time - SESSION_START_TIME))
    else
        echo "0"
    fi
}

# Load memory context at startup (SYN-008)
# Retrieves task-aware memories and writes to .loki/state/memory-context.json
# Note: Uses different file than get_relevant_learnings() in run.sh which writes to relevant-learnings.json
# Usage: load_memory_context [prd_path]
load_memory_context() {
    local prd_path="${1:-}"
    local output_file="$LOKI_DIR/state/memory-context.json"
    local temp_file="$LOKI_DIR/state/.memory-context.json.tmp"

    # Skip if explicitly disabled
    if [[ "${LOKI_SKIP_MEMORY:-}" == "true" ]]; then
        return 0
    fi

    # Check if python3 is available (required for memory system)
    if ! command -v python3 &> /dev/null; then
        echo -e "${YELLOW}Warning: python3 not found - memory context loading disabled${NC}" >&2
        return 0
    fi

    # Check if memory system is available
    if [ ! -d "$LOKI_DIR/memory" ]; then
        return 0
    fi

    # Ensure state directory exists
    mkdir -p "$LOKI_DIR/state"

    # Extract context from PRD if available (first 500 chars)
    # Use base64 encoding to safely pass PRD content to Python (prevents command injection)
    local prd_context_b64=""
    if [ -n "$prd_path" ] && [ -f "$prd_path" ]; then
        prd_context_b64=$(head -c 500 "$prd_path" 2>/dev/null | base64)
    fi

    # Call Python memory retrieval with safe parameter passing via environment variables
    # Export environment variables for Python script (cleaner than shell variable expansion)
    local result
    _LOKI_SKILL_DIR="$SKILL_DIR" _LOKI_DIR="$LOKI_DIR" _LOKI_PRD_CONTEXT_B64="$prd_context_b64" \
    result=$(python3 << 'PYEOF' 2>/dev/null
import sys
import os
import json
import base64

# Get parameters from environment
skill_dir = os.environ.get('_LOKI_SKILL_DIR', '')
loki_dir = os.environ.get('_LOKI_DIR', '')
prd_context_b64 = os.environ.get('_LOKI_PRD_CONTEXT_B64', '')

# Decode PRD context safely
prd_context = ''
if prd_context_b64:
    try:
        prd_context = base64.b64decode(prd_context_b64).decode('utf-8', errors='replace')
    except Exception:
        prd_context = ''

sys.path.insert(0, skill_dir)
try:
    from memory.retrieval import MemoryRetrieval
    from memory.storage import MemoryStorage

    storage = MemoryStorage(f'{loki_dir}/memory')
    retriever = MemoryRetrieval(storage)

    # Build context for task-aware retrieval
    context = {
        'goal': prd_context if prd_context else 'Analyze codebase and improve',
        'phase': 'startup'
    }

    # Retrieve relevant memories
    results = retriever.retrieve_task_aware(context, top_k=5, token_budget=2000)

    # Format output
    output = {
        'timestamp': __import__('datetime').datetime.now().isoformat(),
        'prd_context': prd_context[:200] if prd_context else None,
        'memory_count': len(results),
        'memories': []
    }

    for r in results:
        memory_item = {
            'source': r.get('_source', 'unknown'),
            'score': round(r.get('_weighted_score', r.get('_score', 0)), 3),
            'summary': r.get('summary', r.get('pattern', r.get('goal', '')))[:200],
            'id': r.get('id', '')
        }
        output['memories'].append(memory_item)

    print(json.dumps(output, indent=2))
except ImportError:
    print('{"error": "Memory module not available", "memory_count": 0, "memories": []}')
except Exception as e:
    print(json.dumps({"error": str(e), "memory_count": 0, "memories": []}))
PYEOF
    )

    # Write to output file using atomic write (temp file + rename)
    if [ -n "$result" ]; then
        echo "$result" > "$temp_file" && mv "$temp_file" "$output_file"

        # Emit event
        local memory_count=$(echo "$result" | python3 -c "import sys,json; d=json.load(sys.stdin); print(d.get('memory_count', 0))" 2>/dev/null || echo "0")
        emit_event memory cli load "count=$memory_count" "prd_provided=$([[ -n "$prd_path" ]] && echo 'true' || echo 'false')"

        # Print summary
        if [ "$memory_count" -gt 0 ]; then
            echo -e "${CYAN}Memory:${NC} Loaded $memory_count relevant learnings"
        fi
    else
        # Write empty result using atomic write
        echo '{"timestamp": "'$(date -u +%Y-%m-%dT%H:%M:%SZ)'", "memory_count": 0, "memories": [], "error": "retrieval_failed"}' > "$temp_file" && mv "$temp_file" "$output_file"
    fi

    return 0
}

# Show help
show_help() {
    local version=$(get_version)
    echo -e "${BOLD}Loki Mode v$version${NC}"
    echo ""
    echo "Usage: loki <command> [options]"
    echo ""
    echo "Commands:"
    echo "  start [PRD]      Start Loki Mode (optionally with PRD file)"
    echo "  quick \"task\"     Quick single-task mode (lightweight, 3 iterations max)"
    echo "  demo             Run interactive demo (~60s simulated session)"
    echo "  init             Build a PRD interactively or from templates"
    echo "  issue <url|num>  Generate PRD from GitHub issue and optionally start"
    echo "  stop             Stop execution immediately"
    echo "  pause            Pause after current session"
    echo "  resume           Resume paused execution"
    echo "  status [--json]  Show current status (--json for machine-readable)"
    echo "  logs             Show recent log output"
    echo "  dashboard [cmd]  Dashboard server (start|stop|status|url|open)"
    echo "  provider [cmd]   Manage AI provider (show|set|list|info)"
    echo "  serve            Start dashboard/API server (alias for api start)"
    echo "  api [cmd]        Dashboard/API server (start|stop|status)"
    echo "  sandbox [cmd]    Docker sandbox (start|stop|status|logs|shell|build)"
    echo "  notify [cmd]     Send notifications (test|slack|discord|webhook|status)"
    echo "  voice [cmd]      Voice input for PRD creation (status|listen|dictate|speak|start)"
    echo "  import           Import GitHub issues as tasks"
    echo "  github [cmd]     GitHub integration (sync|export|pr|status)"
    echo "  config [cmd]     Manage configuration (show|init|edit|path)"
    echo "  completions [bash|zsh]  Output shell completion scripts"
    echo "  memory [cmd]     Cross-project learnings (list|show|search|stats)"
    echo "  compound [cmd]   Knowledge compounding (list|show|search|run|stats)"
    echo "  council [cmd]    Completion council (status|verdicts|convergence|force-review|report)"
    echo "  checkpoint|cp    Save/restore session checkpoints"
    echo "  projects         Multi-project registry management"
    echo "  audit            Agent action audit log"
    echo "  enterprise       Enterprise feature management (tokens, OIDC)"
    echo "  metrics          Prometheus/OpenMetrics metrics from dashboard"
    echo "  dogfood          Show self-development statistics"
    echo "  secrets [cmd]    API key status and validation (status|validate)"
    echo "  reset [target]   Reset session state (all|retries|failed)"
    echo "  doctor [--json]  Check system prerequisites"
    echo "  watchdog [cmd]   Process health monitoring (status|help)"
    echo "  version          Show version"
    echo "  help             Show this help"
    echo ""
    echo "Options for 'start':"
    echo "  --provider NAME  AI provider: claude (default), codex, gemini"
    echo "  --parallel       Enable parallel mode with git worktrees"
    echo "  --bg, --background  Run in background mode"
    echo "  --simple         Force simple complexity tier (3 phases)"
    echo "  --complex        Force complex complexity tier (8 phases)"
    echo "  --github         Enable GitHub issue import"
    echo "  --no-dashboard   Disable web dashboard"
    echo "  --sandbox        Run in Docker sandbox for isolation"
    echo "  --skip-memory    Skip loading memory context at startup"
    echo "  --budget USD     Set cost budget limit (display in dashboard/status)"
    echo ""
    echo "Options for 'issue':"
    echo "  --repo OWNER/REPO  Specify repository (default: auto-detect)"
    echo "  --number NUM       Specify issue number (alternative to URL)"
    echo "  --start            Start Loki Mode with generated PRD"
    echo "  --dry-run          Preview generated PRD without saving"
    echo "  --output FILE      Save PRD to custom path (default: .loki/prd-issue-N.md)"
    echo ""
    echo "Examples:"
    echo "  loki demo                     # Run 60-second interactive demo"
    echo "  loki init                     # Build a PRD interactively"
    echo "  loki init -t saas-starter     # Start from a template"
    echo "  loki quick \"add dark mode\"    # Quick single-task mode"
    echo "  loki start ./prd.md           # Start with PRD file"
    echo "  loki start --bg               # Start in background"
    echo "  loki start --parallel         # Start in parallel mode"
    echo "  loki pause                    # Pause execution"
    echo "  loki status                   # Check current status"
    echo "  loki issue 123                # Generate PRD from issue #123"
    echo "  loki issue 123 --start        # Generate PRD and start Loki Mode"
    echo "  loki issue https://github.com/owner/repo/issues/123  # From URL"
    echo ""
    echo "Environment Variables:"
    echo "  See: $RUN_SH (header comments)"
}

# Start Loki Mode
cmd_start() {
    local args=()
    local prd_file=""
    local provider=""

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --help|-h)
                echo -e "${BOLD}loki start${NC} - Start Loki Mode autonomous execution"
                echo ""
                echo "Usage: loki start [PRD] [options]"
                echo ""
                echo "Arguments:"
                echo "  PRD                   Path to PRD file (optional)"
                echo ""
                echo "Options:"
                echo "  --provider NAME       AI provider: claude (default), codex, gemini"
                echo "  --parallel            Enable parallel mode with git worktrees"
                echo "  --bg, --background    Run in background mode"
                echo "  --simple              Force simple complexity tier (3 phases)"
                echo "  --complex             Force complex complexity tier (8 phases)"
                echo "  --github              Enable GitHub issue import"
                echo "  --no-dashboard        Disable web dashboard"
                echo "  --sandbox             Run in Docker sandbox"
                echo "  --skip-memory         Skip loading memory context at startup"
                echo "  --budget USD          Cost budget limit (auto-pause when exceeded)"
                echo "  --yes, -y             Skip confirmation prompts (auto-confirm)"
                echo ""
                echo "Environment Variables:"
                echo "  LOKI_PRD_FILE         Path to PRD file (alternative to positional arg)"
                echo "  LOKI_AUTO_CONFIRM     Set to 'true'/'false' to control prompts (takes precedence over CI)"
                echo "  CI                    Fallback: auto-confirms when 'true' and LOKI_AUTO_CONFIRM is unset"
                echo "  LOKI_MAX_ITERATIONS   Max iteration count"
                echo "  LOKI_BUDGET_LIMIT     Cost budget limit in USD"
                echo ""
                echo "Examples:"
                echo "  loki start                      # Interactive or resume existing"
                echo "  loki start ./prd.md             # Start with PRD file"
                echo "  loki start ./prd.md --parallel  # Parallel mode with worktrees"
                echo "  loki start --provider codex     # Use OpenAI Codex CLI"
                echo "  loki start --yes                # Skip confirmation prompt"
                echo "  LOKI_PRD_FILE=./prd.md loki start  # PRD via env var"
                exit 0
                ;;
            --provider)
                if [[ -n "${2:-}" ]]; then
                    provider="$2"
                    args+=("--provider" "$provider")
                    shift 2
                else
                    echo -e "${RED}--provider requires a value (claude, codex, gemini)${NC}"
                    exit 1
                fi
                ;;
            --provider=*)
                provider="${1#*=}"
                args+=("--provider" "$provider")
                shift
                ;;
            --parallel)
                args+=("--parallel")
                shift
                ;;
            --bg|--background)
                args+=("--bg")
                shift
                ;;
            --simple)
                export LOKI_COMPLEXITY=simple
                shift
                ;;
            --complex)
                export LOKI_COMPLEXITY=complex
                shift
                ;;
            --github)
                export LOKI_GITHUB_IMPORT=true
                shift
                ;;
            --no-dashboard)
                export LOKI_DASHBOARD=false
                shift
                ;;
            --sandbox)
                export LOKI_SANDBOX_MODE=true
                shift
                ;;
            --skip-memory)
                export LOKI_SKIP_MEMORY=true
                shift
                ;;
            --yes|-y)
                export LOKI_AUTO_CONFIRM=true
                shift
                ;;
            --budget)
                if [[ -n "${2:-}" ]]; then
                    if ! echo "$2" | grep -qE '^[0-9]+(\.[0-9]+)?$'; then
                        echo -e "${RED}--budget requires a numeric USD amount (e.g., --budget 5.00)${NC}"
                        exit 1
                    fi
                    export LOKI_BUDGET_LIMIT="$2"
                    shift 2
                else
                    echo -e "${RED}--budget requires a USD amount (e.g., --budget 5.00)${NC}"
                    exit 1
                fi
                ;;
            --budget=*)
                local budget_val="${1#*=}"
                if ! echo "$budget_val" | grep -qE '^[0-9]+(\.[0-9]+)?$'; then
                    echo -e "${RED}--budget requires a numeric USD amount (e.g., --budget=5.00)${NC}"
                    exit 1
                fi
                export LOKI_BUDGET_LIMIT="$budget_val"
                shift
                ;;
            -*)
                echo -e "${RED}Unknown option: $1${NC}"
                exit 1
                ;;
            *)
                prd_file="$1"
                shift
                ;;
        esac
    done

    # Support LOKI_PRD_FILE environment variable as fallback
    if [ -z "$prd_file" ] && [ -n "${LOKI_PRD_FILE:-}" ]; then
        prd_file="$LOKI_PRD_FILE"
    fi

    if [ -n "$prd_file" ]; then
        args+=("$prd_file")
    else
        # No PRD file specified -- warn and confirm before starting
        # Auto-confirm in CI environments or when LOKI_AUTO_CONFIRM is set
        # LOKI_AUTO_CONFIRM takes precedence when explicitly set;
        # fall back to CI env var only when LOKI_AUTO_CONFIRM is unset
        local _auto_confirm="${LOKI_AUTO_CONFIRM:-${CI:-false}}"
        if [[ "$_auto_confirm" == "true" ]]; then
            echo -e "${YELLOW}Warning: No PRD file specified. Auto-confirming (CI mode).${NC}"
        else
            echo -e "${YELLOW}Warning: No PRD file specified.${NC}"
            echo "Loki Mode will analyze the existing codebase and generate"
            echo "a PRD automatically. No requirements document needed."
            echo ""
            echo -e "Continue? [y/N] \c"
            read -r confirm
            if [[ ! "$confirm" =~ ^[Yy] ]]; then
                echo "Aborted. Usage: loki start <path-to-prd.md>"
                exit 0
            fi
        fi
    fi

    # Load saved provider if not specified on command line
    if [ -z "$provider" ]; then
        if [ -f "$LOKI_DIR/state/provider" ]; then
            provider=$(cat "$LOKI_DIR/state/provider" 2>/dev/null)
            if [ -n "$provider" ]; then
                args+=("--provider" "$provider")
            fi
        fi
    fi

    # Determine effective provider for display
    local effective_provider="${provider:-${LOKI_PROVIDER:-claude}}"

    # Handle sandbox mode - delegate to sandbox.sh
    # Skip if we're already inside a sandbox (IS_SANDBOX=1 or /.dockerenv exists)
    if [[ "${LOKI_SANDBOX_MODE:-}" == "true" ]] && [[ "${IS_SANDBOX:-}" != "1" ]] && [[ ! -f /.dockerenv ]]; then
        if [ ! -f "$SANDBOX_SH" ]; then
            echo -e "${RED}Error: sandbox.sh not found at $SANDBOX_SH${NC}"
            exit 1
        fi

        echo -e "${GREEN}Starting Loki Mode in sandbox...${NC}"
        # Load memory context before sandbox start (errors don't block startup)
        load_memory_context "$prd_file" || true
        emit_event session cli start "provider=$effective_provider" "sandbox=true" "prd_path=${prd_file:-}"
        exec "$SANDBOX_SH" start "${args[@]}"
    fi

    # Load memory context before starting (errors don't block startup)
    load_memory_context "$prd_file" || true

    # Show provider info
    echo -e "${GREEN}Starting Loki Mode...${NC}"
    echo -e "${CYAN}Provider:${NC} $effective_provider"
    if [ -f "$LOKI_DIR/state/provider" ]; then
        echo -e "${DIM}  (saved for this project - change with: loki provider set <name>)${NC}"
    else
        echo -e "${DIM}  (default - save for project with: loki provider set <name>)${NC}"
    fi
    echo ""

    # Emit session start event
    emit_event session cli start "provider=$effective_provider" "prd_path=${prd_file:-}"

    # Record session start time for efficiency tracking
    record_session_start

    # Emit learning signal: user preference for provider selection (SYN-018)
    if [ -n "$provider" ]; then
        # User explicitly chose a provider
        emit_learning_signal user_preference \
            --source cli \
            --action "provider_selection" \
            --key "provider" \
            --value "$provider" \
            --rejected '["'"$([ "$provider" != "claude" ] && echo "claude" || echo "codex")'", "'"$([ "$provider" != "gemini" ] && echo "gemini" || echo "codex")'"]' \
            --confidence 0.95
    fi

    # Emit learning signal: workflow pattern for session start
    emit_learning_signal workflow_pattern \
        --source cli \
        --action "session_start" \
        --workflow-name "loki_session" \
        --steps '["init", "load_memory", "start_runner"]' \
        --outcome success \
        --context "{\"provider\":\"$effective_provider\",\"prd_path\":\"${prd_file:-}\"}"

    exec "$RUN_SH" "${args[@]}"
}

# Check if session is running
is_session_running() {
    # Check both possible PID files (loki.pid from run.sh, run.pid legacy)
    local pid_files=("$LOKI_DIR/loki.pid" "$LOKI_DIR/run.pid")
    for pid_file in "${pid_files[@]}"; do
        if [ -f "$pid_file" ]; then
            local pid
            pid=$(cat "$pid_file" 2>/dev/null)
            if [ -n "$pid" ] && kill -0 "$pid" 2>/dev/null; then
                return 0
            fi
        fi
    done
    return 1
}

# Stop execution immediately
cmd_stop() {
    if [ ! -d "$LOKI_DIR" ]; then
        echo -e "${YELLOW}No .loki directory found.${NC}"
        echo "No active session to stop."
        # Emit error pattern for stop without session (SYN-018)
        emit_learning_signal error_pattern \
            --source cli \
            --action "cmd_stop" \
            --error-type "SessionNotFound" \
            --error-message "No .loki directory found" \
            --recovery-steps '["Run loki start first"]' \
            --confidence 0.7
        exit 0
    fi

    if is_session_running; then
        touch "$LOKI_DIR/STOP"

        # Kill the background process and all its children
        local killed_pid=""
        for pid_file in "$LOKI_DIR/loki.pid" "$LOKI_DIR/run.pid"; do
            if [ -f "$pid_file" ]; then
                local pid
                pid=$(cat "$pid_file" 2>/dev/null)
                if [ -n "$pid" ] && kill -0 "$pid" 2>/dev/null; then
                    # Kill all child processes first (SIGTERM)
                    pkill -P "$pid" 2>/dev/null || true
                    # Then kill the parent (SIGTERM)
                    kill "$pid" 2>/dev/null || true
                    killed_pid="$pid"

                    # Wait briefly, then SIGKILL if still alive
                    sleep 1
                    if kill -0 "$pid" 2>/dev/null; then
                        pkill -9 -P "$pid" 2>/dev/null || true
                        kill -9 "$pid" 2>/dev/null || true
                    fi
                fi
                rm -f "$pid_file"
            fi
        done

        # Also kill any orphaned loki-run temp scripts (SIGTERM then SIGKILL)
        pkill -f "loki-run-" 2>/dev/null || true
        sleep 0.5
        pkill -9 -f "loki-run-" 2>/dev/null || true

        # Mark session.json as stopped (skill-invoked sessions)
        if [ -f "$LOKI_DIR/session.json" ]; then
            # Use python for reliable JSON update, fall back to overwrite
            python3 -c "
import json, sys, os
try:
    p = os.path.join(sys.argv[1], 'session.json')
    with open(p, 'r+') as f:
        d = json.load(f)
        d['status'] = 'stopped'
        f.seek(0); f.truncate()
        json.dump(d, f)
except: pass
" "$LOKI_DIR" 2>/dev/null || true
        fi

        # Clean up control files
        rm -f "$LOKI_DIR/STOP" "$LOKI_DIR/PAUSE" "$LOKI_DIR/PAUSED.md" 2>/dev/null

        # Kill dashboard if running
        if [ -f "$LOKI_DIR/dashboard/dashboard.pid" ]; then
            local dash_pid
            dash_pid=$(cat "$LOKI_DIR/dashboard/dashboard.pid" 2>/dev/null)
            if [ -n "$dash_pid" ] && kill -0 "$dash_pid" 2>/dev/null; then
                kill "$dash_pid" 2>/dev/null || true
                sleep 0.5
                kill -9 "$dash_pid" 2>/dev/null || true
            fi
            rm -f "$LOKI_DIR/dashboard/dashboard.pid"
        fi

        # Emit session stop event
        emit_event session cli stop "reason=user_requested"
        # Emit success pattern for clean stop (SYN-018)
        emit_learning_signal success_pattern \
            --source cli \
            --action "cmd_stop" \
            --pattern-name "session_stop" \
            --action-sequence '["check_session", "send_stop_signal"]' \
            --outcome success \
            --confidence 0.9

        if [ -n "$killed_pid" ]; then
            echo -e "${RED}Stopped Loki Mode (PID: $killed_pid)${NC}"
        else
            echo -e "${RED}STOP signal sent. Execution will halt immediately.${NC}"
        fi
    else
        echo -e "${YELLOW}No active session running.${NC}"
        if [ -f "$LOKI_DIR/STOP" ]; then
            echo "STOP signal already present."
        else
            echo "Start a session with: loki start"
        fi
    fi
}

# Pause after current session
cmd_pause() {
    if [ ! -d "$LOKI_DIR" ]; then
        echo -e "${YELLOW}No .loki directory found.${NC}"
        echo "No active session to pause."
        exit 0
    fi

    if is_session_running; then
        touch "$LOKI_DIR/PAUSE"
        # Emit session pause event
        emit_event session cli pause "reason=user_requested"
        # Emit user preference for pause action (SYN-018)
        emit_learning_signal user_preference \
            --source cli \
            --action "session_control" \
            --key "control_action" \
            --value "pause" \
            --rejected '["stop", "continue"]' \
            --confidence 0.9
        echo -e "${YELLOW}PAUSE signal sent. Execution will pause after current task.${NC}"
        echo -e "${DIM}Resume with: loki resume${NC}"
    else
        echo -e "${YELLOW}No active session running.${NC}"
        if [ -f "$LOKI_DIR/PAUSE" ]; then
            echo "PAUSE signal already present."
        else
            echo "Start a session with: loki start"
        fi
    fi
}

# Resume paused execution
cmd_resume() {
    if [ ! -d "$LOKI_DIR" ]; then
        echo -e "${YELLOW}No .loki directory found.${NC}"
        echo "No session to resume. Start a session with: loki start"
        exit 0
    fi

    # Check if there is anything to resume before touching signal files
    local has_pause_signal=false
    local has_stop_signal=false
    [ -f "$LOKI_DIR/PAUSE" ] && has_pause_signal=true
    [ -f "$LOKI_DIR/STOP" ] && has_stop_signal=true
    local session_running=false
    is_session_running && session_running=true

    # If nothing is paused/stopped and no session is running, exit early
    if ! $has_pause_signal && ! $has_stop_signal && ! $session_running; then
        echo -e "${YELLOW}No session to resume.${NC}"
        echo "Start a session with: loki start"
        exit 0
    fi

    # Clear the signal file if one exists
    local removed_signal=""
    if $has_pause_signal; then
        rm -f "$LOKI_DIR/PAUSE"
        removed_signal="PAUSE"
    elif $has_stop_signal; then
        rm -f "$LOKI_DIR/STOP"
        removed_signal="STOP"
    fi

    if [ -n "$removed_signal" ]; then
        # Emit session resume event
        emit_event session cli resume "cleared_signal=$removed_signal"
        # Emit success pattern for resume (SYN-018)
        emit_learning_signal success_pattern \
            --source cli \
            --action "session_resume" \
            --pattern-name "resume_after_$removed_signal" \
            --action-sequence '["check_signals", "clear_signal", "resume"]' \
            --outcome success \
            --confidence 0.85
        if $session_running; then
            echo -e "${GREEN}$removed_signal signal cleared. Session will resume automatically.${NC}"
        else
            echo -e "${GREEN}$removed_signal signal cleared.${NC}"
            echo "Session is not running. Start with: loki start"
        fi
    else
        # Session is running but no signals to clear
        echo -e "${CYAN}Session is running normally. Nothing to resume.${NC}"
    fi
}

# Show current status
cmd_status() {
    require_jq

    if [ ! -d "$LOKI_DIR" ]; then
        echo -e "${BOLD}Loki Mode Status${NC}"
        echo ""
        echo -e "${YELLOW}No active session found.${NC}"
        echo "Loki Mode has not been initialized in this directory."
        echo ""
        echo "To start a session:"
        echo "  loki start <prd>              - Start with a PRD file"
        echo "  loki start                    - Start without a PRD"
        echo ""
        echo -e "${DIM}Current directory: $(pwd)${NC}"
        return 0
    fi

    echo -e "${BOLD}Loki Mode Status${NC}"
    echo ""

    # Show current provider
    local saved_provider=""
    if [ -f "$LOKI_DIR/state/provider" ]; then
        saved_provider=$(cat "$LOKI_DIR/state/provider" 2>/dev/null)
    fi
    local current_provider="${saved_provider:-${LOKI_PROVIDER:-claude}}"
    # Show provider with capability
    local capability="full features"
    case "$current_provider" in
        codex|gemini)
            capability="degraded mode"
            ;;
    esac
    echo -e "${CYAN}Provider:${NC} $current_provider ($capability)"
    echo -e "${DIM}  Switch with: loki provider set <claude|codex|gemini>${NC}"
    echo ""

    # Check for signals first (more prominent)
    if [ -f "$LOKI_DIR/PAUSE" ]; then
        echo -e "${YELLOW}Status: PAUSED${NC}"
        echo -e "${DIM}  Resume with: loki resume${NC}"
        echo ""
    elif [ -f "$LOKI_DIR/STOP" ]; then
        echo -e "${RED}Status: STOPPED${NC}"
        echo -e "${DIM}  Clear with: loki resume${NC}"
        echo ""
    fi

    # Check status file
    if [ -f "$LOKI_DIR/STATUS.txt" ]; then
        echo -e "${CYAN}Session Info:${NC}"
        cat "$LOKI_DIR/STATUS.txt"
        echo ""
    fi

    # Check orchestrator state
    if [ -f "$LOKI_DIR/state/orchestrator.json" ]; then
        echo -e "${CYAN}Orchestrator State:${NC}"
        jq -r '.currentPhase // "unknown"' "$LOKI_DIR/state/orchestrator.json" 2>/dev/null || echo "unknown"
    fi

    # Check pending tasks
    if [ -f "$LOKI_DIR/queue/pending.json" ]; then
        local task_count=$(jq '.tasks | length' "$LOKI_DIR/queue/pending.json" 2>/dev/null || echo "0")
        echo -e "${CYAN}Pending Tasks:${NC} $task_count"
    fi

    # Check budget
    if [ -f "$LOKI_DIR/metrics/budget.json" ]; then
        local budget_limit budget_used budget_remaining
        budget_limit=$(LOKI_BUDGET_FILE="$LOKI_DIR/metrics/budget.json" python3 -c "import json,os; d=json.load(open(os.environ['LOKI_BUDGET_FILE'])); print(d.get('budget_limit', 0))" 2>/dev/null || echo "0")
        budget_used=$(LOKI_BUDGET_FILE="$LOKI_DIR/metrics/budget.json" python3 -c "import json,os; d=json.load(open(os.environ['LOKI_BUDGET_FILE'])); print(round(d.get('budget_used', 0), 2))" 2>/dev/null || echo "0")
        if [ "$budget_limit" != "0" ]; then
            echo -e "${CYAN}Budget:${NC} \$$budget_used / \$$budget_limit"
        fi
    fi

    # Check dashboard
    if [ -f "$LOKI_DIR/dashboard/dashboard.pid" ]; then
        local pid=$(cat "$LOKI_DIR/dashboard/dashboard.pid" 2>/dev/null)
        if [ -n "$pid" ] && kill -0 "$pid" 2>/dev/null; then
            local port=${LOKI_DASHBOARD_PORT:-57374}
            echo -e "${CYAN}Dashboard:${NC} http://127.0.0.1:$port/"
        fi
    fi
}

# JSON output for loki status --json
cmd_status_json() {
    local skill_dir="$SKILL_DIR"
    local loki_dir="$LOKI_DIR"
    local dashboard_port="${LOKI_DASHBOARD_PORT:-57374}"
    local env_provider="${LOKI_PROVIDER:-claude}"

    python3 -c "
import json, os, sys, time

skill_dir = sys.argv[1]
loki_dir = sys.argv[2]
dashboard_port = sys.argv[3]
env_provider = sys.argv[4]
result = {}

# Version
version_file = os.path.join(skill_dir, 'VERSION')
if os.path.isfile(version_file):
    with open(version_file) as f:
        result['version'] = f.read().strip()
else:
    result['version'] = 'unknown'

# Check if session exists
if not os.path.isdir(loki_dir):
    result['status'] = 'inactive'
    result['phase'] = None
    result['iteration'] = 0
    result['provider'] = env_provider
    result['dashboard_url'] = None
    result['pid'] = None
    result['elapsed_time'] = 0
    result['task_counts'] = {'total': 0, 'completed': 0, 'failed': 0, 'pending': 0}
    print(json.dumps(result, indent=2))
    sys.exit(0)

# Status from signals and session.json
if os.path.isfile(os.path.join(loki_dir, 'PAUSE')):
    result['status'] = 'paused'
elif os.path.isfile(os.path.join(loki_dir, 'STOP')):
    result['status'] = 'stopped'
else:
    session_file = os.path.join(loki_dir, 'session.json')
    if os.path.isfile(session_file):
        try:
            with open(session_file) as f:
                session = json.load(f)
            result['status'] = session.get('status', 'unknown')
        except Exception:
            result['status'] = 'unknown'
    else:
        result['status'] = 'unknown'

# Phase and iteration from dashboard-state.json
ds_file = os.path.join(loki_dir, 'dashboard-state.json')
if os.path.isfile(ds_file):
    try:
        with open(ds_file) as f:
            ds = json.load(f)
        result['phase'] = ds.get('phase', ds.get('currentPhase'))
        result['iteration'] = ds.get('iteration', ds.get('currentIteration', 0))
    except Exception:
        result['phase'] = None
        result['iteration'] = 0
else:
    orch_file = os.path.join(loki_dir, 'state', 'orchestrator.json')
    if os.path.isfile(orch_file):
        try:
            with open(orch_file) as f:
                orch = json.load(f)
            result['phase'] = orch.get('currentPhase')
            result['iteration'] = orch.get('currentIteration', 0)
        except Exception:
            result['phase'] = None
            result['iteration'] = 0
    else:
        result['phase'] = None
        result['iteration'] = 0

# Provider
provider_file = os.path.join(loki_dir, 'state', 'provider')
if os.path.isfile(provider_file):
    with open(provider_file) as f:
        result['provider'] = f.read().strip()
else:
    result['provider'] = env_provider

# PID
pid_file = os.path.join(loki_dir, 'loki.pid')
if os.path.isfile(pid_file):
    try:
        with open(pid_file) as f:
            result['pid'] = int(f.read().strip())
    except (ValueError, Exception):
        result['pid'] = None
else:
    result['pid'] = None

# Elapsed time from session.json
session_file = os.path.join(loki_dir, 'session.json')
if os.path.isfile(session_file):
    try:
        with open(session_file) as f:
            session = json.load(f)
        start_time = session.get('start_time', session.get('startTime'))
        if start_time:
            if isinstance(start_time, (int, float)):
                result['elapsed_time'] = int(time.time() - start_time)
            else:
                from datetime import datetime
                dt = datetime.fromisoformat(start_time.replace('Z', '+00:00'))
                result['elapsed_time'] = int(time.time() - dt.timestamp())
        else:
            result['elapsed_time'] = 0
    except Exception:
        result['elapsed_time'] = 0
else:
    result['elapsed_time'] = 0

# Dashboard URL
dashboard_pid_file = os.path.join(loki_dir, 'dashboard', 'dashboard.pid')
dashboard_url = None
if os.path.isfile(dashboard_pid_file):
    try:
        with open(dashboard_pid_file) as f:
            dpid = int(f.read().strip())
        os.kill(dpid, 0)
        dashboard_url = 'http://127.0.0.1:' + dashboard_port + '/'
    except (ProcessLookupError, PermissionError, ValueError, Exception):
        pass
result['dashboard_url'] = dashboard_url

# Task counts from queue files
task_counts = {'total': 0, 'completed': 0, 'failed': 0, 'pending': 0}
queue_dir = os.path.join(loki_dir, 'queue')
if os.path.isdir(queue_dir):
    for name, key in [('pending.json', 'pending'), ('completed.json', 'completed'), ('failed.json', 'failed')]:
        fpath = os.path.join(queue_dir, name)
        if os.path.isfile(fpath):
            try:
                with open(fpath) as f:
                    data = json.load(f)
                if isinstance(data, list):
                    task_counts[key] = len(data)
                elif isinstance(data, dict) and 'tasks' in data:
                    task_counts[key] = len(data['tasks'])
            except Exception:
                pass
    task_counts['total'] = task_counts['pending'] + task_counts['completed'] + task_counts['failed']
result['task_counts'] = task_counts

print(json.dumps(result, indent=2))
" "$skill_dir" "$loki_dir" "$dashboard_port" "$env_provider"

    if [ $? -ne 0 ]; then
        echo '{"error": "Failed to generate JSON status. Ensure python3 is available."}' >&2
        return 1
    fi
}

# Provider management
cmd_provider() {
    local subcommand="${1:-show}"
    shift || true

    case "$subcommand" in
        show|current)
            cmd_provider_show
            ;;
        set)
            cmd_provider_set "$@"
            ;;
        list)
            cmd_provider_list
            ;;
        info)
            cmd_provider_info "$@"
            ;;
        *)
            echo -e "${BOLD}Loki Mode Provider Management${NC}"
            echo ""
            echo "Usage: loki provider <command>"
            echo ""
            echo "Commands:"
            echo "  show     Show current provider (default)"
            echo "  set      Set provider for this project"
            echo "  list     List available providers"
            echo "  info     Show provider details"
            echo ""
            echo "Examples:"
            echo "  loki provider show"
            echo "  loki provider set claude"
            echo "  loki provider set codex"
            echo "  loki provider list"
            echo "  loki provider info gemini"
            ;;
    esac
}

cmd_provider_show() {
    local saved_provider=""
    if [ -f "$LOKI_DIR/state/provider" ]; then
        saved_provider=$(cat "$LOKI_DIR/state/provider" 2>/dev/null)
    fi

    local current="${saved_provider:-${LOKI_PROVIDER:-claude}}"

    echo -e "${BOLD}Current Provider${NC}"
    echo ""
    echo -e "${CYAN}Provider:${NC} $current"

    # Show capability status
    case "$current" in
        claude)
            echo -e "${GREEN}Status:${NC}   Full features (subagents, parallel, MCP)"
            ;;
        codex|gemini)
            echo -e "${YELLOW}Status:${NC}   Degraded mode (sequential only)"
            ;;
    esac

    if [ -n "$saved_provider" ]; then
        echo -e "${DIM}(saved in .loki/state/provider)${NC}"
    else
        echo -e "${DIM}(default - not explicitly set)${NC}"
    fi

    echo ""
    echo -e "Switch provider: ${CYAN}loki provider set <name>${NC}"
    echo -e "Available:       ${CYAN}loki provider list${NC}"
}

cmd_provider_set() {
    local new_provider="${1:-}"

    if [ -z "$new_provider" ]; then
        echo -e "${RED}Error: Provider name required${NC}"
        echo "Usage: loki provider set <claude|codex|gemini>"
        exit 1
    fi

    # Validate provider
    case "$new_provider" in
        claude|codex|gemini)
            ;;
        *)
            echo -e "${RED}Error: Invalid provider '$new_provider'${NC}"
            echo "Valid providers: claude, codex, gemini"
            exit 1
            ;;
    esac

    # Check if CLI is installed
    if ! command -v "$new_provider" &> /dev/null; then
        echo -e "${YELLOW}Warning: '$new_provider' CLI not found in PATH${NC}"
        echo ""
        case "$new_provider" in
            claude)
                echo "Install: npm install -g @anthropic-ai/claude-code"
                ;;
            codex)
                echo "Install: npm install -g @openai/codex"
                ;;
            gemini)
                echo "Install: npm install -g @google/gemini-cli"
                ;;
        esac
        echo ""
        echo -e "${DIM}Setting provider anyway...${NC}"
    fi

    # Save provider
    mkdir -p "$LOKI_DIR/state"
    echo "$new_provider" > "$LOKI_DIR/state/provider"

    echo -e "${GREEN}Provider set to: $new_provider${NC}"
    echo ""
    echo "This will be used for all future runs in this project."
    echo "Override temporarily with: loki start --provider <name>"
}

cmd_provider_list() {
    echo -e "${BOLD}Available Providers${NC}"
    echo ""

    local saved_provider=""
    if [ -f "$LOKI_DIR/state/provider" ]; then
        saved_provider=$(cat "$LOKI_DIR/state/provider" 2>/dev/null)
    fi
    local current="${saved_provider:-${LOKI_PROVIDER:-claude}}"

    # Check which CLIs are installed
    local claude_status="${RED}not installed${NC}"
    local codex_status="${RED}not installed${NC}"
    local gemini_status="${RED}not installed${NC}"

    if command -v claude &> /dev/null; then
        claude_status="${GREEN}installed${NC}"
    fi
    if command -v codex &> /dev/null; then
        codex_status="${GREEN}installed${NC}"
    fi
    if command -v gemini &> /dev/null; then
        gemini_status="${GREEN}installed${NC}"
    fi

    # Display providers
    local marker=""
    [ "$current" = "claude" ] && marker=" ${CYAN}(current)${NC}"
    echo -e "  claude  - Claude Code (Anthropic)     $claude_status$marker"

    marker=""
    [ "$current" = "codex" ] && marker=" ${CYAN}(current)${NC}"
    echo -e "  codex   - Codex CLI (OpenAI)          $codex_status$marker"

    marker=""
    [ "$current" = "gemini" ] && marker=" ${CYAN}(current)${NC}"
    echo -e "  gemini  - Gemini CLI (Google)         $gemini_status$marker"

    echo ""
    echo -e "Set provider: ${CYAN}loki provider set <name>${NC}"
}

cmd_provider_info() {
    local provider="${1:-${LOKI_PROVIDER:-claude}}"

    echo -e "${BOLD}Provider: $provider${NC}"
    echo ""

    case "$provider" in
        claude)
            echo "Name:        Claude Code"
            echo "Vendor:      Anthropic"
            echo "CLI:         claude"
            echo "Flag:        --dangerously-skip-permissions"
            echo ""
            echo "Features:"
            echo "  - Full autonomous mode"
            echo "  - Task tool for subagents"
            echo "  - Parallel execution"
            echo "  - MCP server support"
            echo ""
            echo "Status:      Full features"
            ;;
        codex)
            echo "Name:        Codex CLI"
            echo "Vendor:      OpenAI"
            echo "CLI:         codex"
            echo "Flag:        --full-auto"
            echo ""
            echo "Features:"
            echo "  - Autonomous mode"
            echo "  - Sequential only (no subagents)"
            echo ""
            echo "Status:      Degraded mode"
            ;;
        gemini)
            echo "Name:        Gemini CLI"
            echo "Vendor:      Google"
            echo "CLI:         gemini"
            echo "Flag:        --approval-mode=yolo"
            echo ""
            echo "Features:"
            echo "  - Autonomous mode"
            echo "  - Sequential only (no subagents)"
            echo ""
            echo "Status:      Degraded mode"
            ;;
        *)
            echo -e "${RED}Unknown provider: $provider${NC}"
            exit 1
            ;;
    esac
}

# Dashboard server management - project-local, unified with run.sh
DASHBOARD_PID_DIR="${LOKI_DIR}/dashboard"
DASHBOARD_PID_FILE="${DASHBOARD_PID_DIR}/dashboard.pid"
DASHBOARD_DEFAULT_PORT=57374
DASHBOARD_DEFAULT_HOST="127.0.0.1"

cmd_dashboard() {
    local subcommand="${1:-}"

    # If no subcommand provided, show help (backward compatible with old behavior)
    if [ -z "$subcommand" ]; then
        cmd_dashboard_help
        exit 0
    fi

    shift || true

    case "$subcommand" in
        start)
            cmd_dashboard_start "$@"
            ;;
        stop)
            cmd_dashboard_stop
            ;;
        status)
            cmd_dashboard_status
            ;;
        url)
            cmd_dashboard_url "$@"
            ;;
        open)
            cmd_dashboard_open
            ;;
        --help|-h|help)
            cmd_dashboard_help
            ;;
        *)
            echo -e "${RED}Unknown dashboard command: $subcommand${NC}"
            echo "Run 'loki dashboard help' for usage."
            exit 1
            ;;
    esac
}

cmd_dashboard_help() {
    echo -e "${BOLD}Loki Mode Dashboard Server${NC}"
    echo ""
    echo "Usage: loki dashboard <command> [options]"
    echo ""
    echo "Commands:"
    echo "  start    Start the dashboard server"
    echo "  stop     Stop the dashboard server"
    echo "  status   Show server status and URL"
    echo "  url      Get the dashboard URL"
    echo "  open     Open dashboard in browser"
    echo "  help     Show this help"
    echo ""
    echo "Options for 'start':"
    echo "  --port PORT        Port to listen on (default: $DASHBOARD_DEFAULT_PORT)"
    echo "  --host HOST        Host to bind to (default: $DASHBOARD_DEFAULT_HOST)"
    echo "  --tls-cert PATH    Path to PEM certificate (enables HTTPS)"
    echo "  --tls-key PATH     Path to PEM private key (enables HTTPS)"
    echo ""
    echo "Options for 'url':"
    echo "  --format FMT   Output format: text (default) or json"
    echo ""
    echo "Environment:"
    echo "  LOKI_DASHBOARD_PORT  Default port (overrides $DASHBOARD_DEFAULT_PORT)"
    echo "  LOKI_DASHBOARD_HOST  Default host (overrides $DASHBOARD_DEFAULT_HOST)"
    echo "  LOKI_TLS_CERT        Path to PEM certificate (enables HTTPS)"
    echo "  LOKI_TLS_KEY         Path to PEM private key (enables HTTPS)"
    echo ""
    echo "Examples:"
    echo "  loki dashboard start                  # Start on default port"
    echo "  loki dashboard start --port 8080      # Start on port 8080"
    echo "  loki dashboard start --tls-cert cert.pem --tls-key key.pem"
    echo "  loki dashboard status                 # Check if running"
    echo "  loki dashboard url --format json      # Get URL as JSON"
    echo "  loki dashboard open                   # Open in browser"
    echo "  loki dashboard stop                   # Stop server"
}

cmd_dashboard_start() {
    local port="${LOKI_DASHBOARD_PORT:-$DASHBOARD_DEFAULT_PORT}"
    local host="${LOKI_DASHBOARD_HOST:-$DASHBOARD_DEFAULT_HOST}"
    local tls_cert="${LOKI_TLS_CERT:-}"
    local tls_key="${LOKI_TLS_KEY:-}"

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --port)
                if [[ -n "${2:-}" ]]; then
                    port="$2"
                    shift 2
                else
                    echo -e "${RED}--port requires a value${NC}"
                    exit 1
                fi
                ;;
            --port=*)
                port="${1#*=}"
                shift
                ;;
            --host)
                if [[ -n "${2:-}" ]]; then
                    host="$2"
                    shift 2
                else
                    echo -e "${RED}--host requires a value${NC}"
                    exit 1
                fi
                ;;
            --host=*)
                host="${1#*=}"
                shift
                ;;
            --tls-cert)
                if [[ -n "${2:-}" ]]; then
                    tls_cert="$2"
                    shift 2
                else
                    echo -e "${RED}--tls-cert requires a path${NC}"
                    exit 1
                fi
                ;;
            --tls-cert=*)
                tls_cert="${1#*=}"
                shift
                ;;
            --tls-key)
                if [[ -n "${2:-}" ]]; then
                    tls_key="$2"
                    shift 2
                else
                    echo -e "${RED}--tls-key requires a path${NC}"
                    exit 1
                fi
                ;;
            --tls-key=*)
                tls_key="${1#*=}"
                shift
                ;;
            --help|-h)
                cmd_dashboard_help
                exit 0
                ;;
            *)
                echo -e "${RED}Unknown option: $1${NC}"
                echo "Run 'loki dashboard start --help' for usage."
                exit 1
                ;;
        esac
    done

    # Validate port is numeric
    if [[ ! "$port" =~ ^[0-9]+$ ]]; then
        echo -e "${RED}Invalid port: $port${NC}"
        echo "Port must be a number."
        exit 1
    fi

    # Check if Python is available
    if ! command -v python &> /dev/null && ! command -v python3 &> /dev/null; then
        echo -e "${RED}Error: Python not found${NC}"
        echo "Python is required for the dashboard server."
        echo "Install with: brew install python"
        exit 1
    fi

    # Determine python command
    local python_cmd="python3"
    if ! command -v python3 &> /dev/null; then
        python_cmd="python"
    fi

    # Check if already running
    if [ -f "$DASHBOARD_PID_FILE" ]; then
        local existing_pid
        existing_pid=$(cat "$DASHBOARD_PID_FILE" 2>/dev/null)
        if [ -n "$existing_pid" ] && kill -0 "$existing_pid" 2>/dev/null; then
            echo -e "${YELLOW}Dashboard server already running (PID: $existing_pid)${NC}"
            echo ""
            cmd_dashboard_status
            exit 0
        fi
        # Stale PID file, remove it
        rm -f "$DASHBOARD_PID_FILE"
    fi

    # Check if port is already in use
    if command -v lsof &> /dev/null; then
        if lsof -i ":$port" &> /dev/null; then
            echo -e "${RED}Error: Port $port is already in use${NC}"
            echo ""
            echo "Check what's using the port:"
            echo "  lsof -i :$port"
            echo ""
            echo "Or use a different port:"
            echo "  loki dashboard start --port 8080"
            exit 1
        fi
    fi

    # Ensure PID directory exists
    mkdir -p "$DASHBOARD_PID_DIR"

    # Create log directory
    local log_dir="${DASHBOARD_PID_DIR}/logs"
    mkdir -p "$log_dir"
    local log_file="${log_dir}/dashboard.log"

    # Determine URL scheme based on TLS
    local url_scheme="http"
    local tls_info=""
    if [ -n "$tls_cert" ] && [ -n "$tls_key" ]; then
        url_scheme="https"
        tls_info=" (TLS enabled)"
    fi

    echo -e "${GREEN}Starting dashboard server...${NC}"
    echo -e "${CYAN}Host:${NC} $host"
    echo -e "${CYAN}Port:${NC} $port"
    if [ -n "$tls_info" ]; then
        echo -e "${CYAN}TLS:${NC}  enabled"
    fi
    echo ""

    # Start the dashboard server in background
    # LOKI_SKILL_DIR tells server.py where to find static files
    LOKI_DIR="$LOKI_DIR" LOKI_SKILL_DIR="$SKILL_DIR" PYTHONPATH="$SKILL_DIR" \
        LOKI_DASHBOARD_HOST="$host" LOKI_DASHBOARD_PORT="$port" \
        LOKI_TLS_CERT="$tls_cert" LOKI_TLS_KEY="$tls_key" \
        nohup "$python_cmd" -m dashboard.server > "$log_file" 2>&1 &
    local new_pid=$!

    # Save PID
    echo "$new_pid" > "$DASHBOARD_PID_FILE"

    # Also save port and host for status command
    echo "$port" > "${DASHBOARD_PID_DIR}/port"
    echo "$host" > "${DASHBOARD_PID_DIR}/host"
    echo "$url_scheme" > "${DASHBOARD_PID_DIR}/scheme"

    # Wait a moment and check if process is still running
    sleep 1

    if kill -0 "$new_pid" 2>/dev/null; then
        local url="${url_scheme}://${host}:${port}"
        echo -e "${GREEN}Dashboard server started${NC}"
        echo ""
        echo "  PID:  $new_pid"
        echo "  URL:  $url"
        echo "  Logs: $log_file"
        echo ""
        echo -e "Open in browser: ${CYAN}loki dashboard open${NC}"
        echo -e "Check status:    ${CYAN}loki dashboard status${NC}"
        echo -e "Stop server:     ${CYAN}loki dashboard stop${NC}"
    else
        rm -f "$DASHBOARD_PID_FILE"
        echo -e "${RED}Failed to start dashboard server${NC}"
        echo ""
        echo "Check the log file for errors:"
        echo "  cat $log_file"
        exit 1
    fi
}

cmd_dashboard_stop() {
    if [ ! -f "$DASHBOARD_PID_FILE" ]; then
        echo -e "${YELLOW}Dashboard server is not running${NC}"
        echo "(No PID file found at $DASHBOARD_PID_FILE)"
        exit 0
    fi

    local pid
    pid=$(cat "$DASHBOARD_PID_FILE" 2>/dev/null)

    if [ -z "$pid" ]; then
        rm -f "$DASHBOARD_PID_FILE"
        echo -e "${YELLOW}Dashboard server is not running (empty PID file)${NC}"
        exit 0
    fi

    if kill -0 "$pid" 2>/dev/null; then
        echo -e "${GREEN}Stopping dashboard server (PID: $pid)...${NC}"
        kill "$pid" 2>/dev/null

        # Wait for process to terminate
        local wait_count=0
        while kill -0 "$pid" 2>/dev/null && [ $wait_count -lt 10 ]; do
            sleep 0.5
            ((wait_count++))
        done

        # Force kill if still running
        if kill -0 "$pid" 2>/dev/null; then
            echo -e "${YELLOW}Process did not terminate gracefully, force killing...${NC}"
            kill -9 "$pid" 2>/dev/null
        fi

        rm -f "$DASHBOARD_PID_FILE"
        echo -e "${GREEN}Dashboard server stopped${NC}"
    else
        rm -f "$DASHBOARD_PID_FILE"
        echo -e "${YELLOW}Dashboard server was not running (stale PID file removed)${NC}"
    fi
}

cmd_dashboard_status() {
    echo -e "${BOLD}Dashboard Server Status${NC}"
    echo ""

    if [ ! -f "$DASHBOARD_PID_FILE" ]; then
        echo -e "${YELLOW}Status: Not running${NC}"
        echo ""
        echo -e "Start with: ${CYAN}loki dashboard start${NC}"
        return 0
    fi

    local pid
    pid=$(cat "$DASHBOARD_PID_FILE" 2>/dev/null)

    if [ -z "$pid" ]; then
        echo -e "${YELLOW}Status: Not running (empty PID file)${NC}"
        rm -f "$DASHBOARD_PID_FILE"
        return 0
    fi

    if kill -0 "$pid" 2>/dev/null; then
        # Read saved host, port, and scheme
        local host="${DASHBOARD_DEFAULT_HOST}"
        local port="${DASHBOARD_DEFAULT_PORT}"
        local scheme="http"

        if [ -f "${DASHBOARD_PID_DIR}/host" ]; then
            host=$(cat "${DASHBOARD_PID_DIR}/host" 2>/dev/null)
        fi
        if [ -f "${DASHBOARD_PID_DIR}/port" ]; then
            port=$(cat "${DASHBOARD_PID_DIR}/port" 2>/dev/null)
        fi
        if [ -f "${DASHBOARD_PID_DIR}/scheme" ]; then
            scheme=$(cat "${DASHBOARD_PID_DIR}/scheme" 2>/dev/null)
        fi

        local url="${scheme}://${host}:${port}"

        echo -e "${GREEN}Status: Running${NC}"
        echo ""
        echo "  PID:  $pid"
        echo "  Host: $host"
        echo "  Port: $port"
        if [ "$scheme" = "https" ]; then
            echo "  TLS:  enabled"
        fi
        echo "  URL:  $url"
        echo ""

        # Check if server is responding
        local curl_flags="-s --connect-timeout 2"
        if [ "$scheme" = "https" ]; then
            curl_flags="$curl_flags -k"
        fi
        if command -v curl &> /dev/null; then
            if curl $curl_flags "$url" &> /dev/null; then
                echo -e "${GREEN}Server is responding${NC}"
            else
                echo -e "${YELLOW}Server process running but not responding on $url${NC}"
                echo "The server may still be starting up."
            fi
        fi

        echo ""
        echo -e "Open in browser: ${CYAN}loki dashboard open${NC}"
        echo -e "Stop server:     ${CYAN}loki dashboard stop${NC}"
    else
        echo -e "${YELLOW}Status: Not running (stale PID file)${NC}"
        rm -f "$DASHBOARD_PID_FILE"
        echo ""
        echo -e "Start with: ${CYAN}loki dashboard start${NC}"
    fi
}

cmd_dashboard_url() {
    local format="text"

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --format)
                if [[ -n "${2:-}" ]]; then
                    format="$2"
                    shift 2
                else
                    echo -e "${RED}--format requires a value (text or json)${NC}"
                    exit 1
                fi
                ;;
            --format=*)
                format="${1#*=}"
                shift
                ;;
            --help|-h)
                echo "Usage: loki dashboard url [--format text|json]"
                exit 0
                ;;
            *)
                echo -e "${RED}Unknown option: $1${NC}"
                exit 1
                ;;
        esac
    done

    # Validate format
    if [[ "$format" != "text" && "$format" != "json" ]]; then
        echo -e "${RED}Invalid format: $format${NC}"
        echo "Valid formats: text, json"
        exit 1
    fi

    # Check if running
    if [ ! -f "$DASHBOARD_PID_FILE" ]; then
        if [[ "$format" == "json" ]]; then
            echo '{"running":false,"error":"Dashboard server is not running"}'
        else
            echo -e "${YELLOW}Dashboard server is not running${NC}"
            echo "Start with: loki dashboard start"
        fi
        exit 1
    fi

    local pid
    pid=$(cat "$DASHBOARD_PID_FILE" 2>/dev/null)

    if [ -z "$pid" ] || ! kill -0 "$pid" 2>/dev/null; then
        rm -f "$DASHBOARD_PID_FILE"
        if [[ "$format" == "json" ]]; then
            echo '{"running":false,"error":"Dashboard server is not running"}'
        else
            echo -e "${YELLOW}Dashboard server is not running${NC}"
            echo "Start with: loki dashboard start"
        fi
        exit 1
    fi

    # Read saved host, port, and scheme
    local host="${DASHBOARD_DEFAULT_HOST}"
    local port="${DASHBOARD_DEFAULT_PORT}"
    local scheme="http"

    if [ -f "${DASHBOARD_PID_DIR}/host" ]; then
        host=$(cat "${DASHBOARD_PID_DIR}/host" 2>/dev/null)
    fi
    if [ -f "${DASHBOARD_PID_DIR}/port" ]; then
        port=$(cat "${DASHBOARD_PID_DIR}/port" 2>/dev/null)
    fi
    if [ -f "${DASHBOARD_PID_DIR}/scheme" ]; then
        scheme=$(cat "${DASHBOARD_PID_DIR}/scheme" 2>/dev/null)
    fi

    local url="${scheme}://${host}:${port}"

    if [[ "$format" == "json" ]]; then
        echo "{\"running\":true,\"url\":\"$url\",\"scheme\":\"$scheme\",\"host\":\"$host\",\"port\":$port,\"pid\":$pid}"
    else
        echo "$url"
    fi
}

cmd_dashboard_open() {
    # Check if server is running
    if [ ! -f "$DASHBOARD_PID_FILE" ]; then
        echo -e "${YELLOW}Dashboard server is not running${NC}"
        echo ""
        echo -e "Start with: ${CYAN}loki dashboard start${NC}"
        exit 1
    fi

    local pid
    pid=$(cat "$DASHBOARD_PID_FILE" 2>/dev/null)

    if [ -z "$pid" ] || ! kill -0 "$pid" 2>/dev/null; then
        rm -f "$DASHBOARD_PID_FILE"
        echo -e "${YELLOW}Dashboard server is not running${NC}"
        echo ""
        echo -e "Start with: ${CYAN}loki dashboard start${NC}"
        exit 1
    fi

    # Read saved host, port, and scheme
    local host="${DASHBOARD_DEFAULT_HOST}"
    local port="${DASHBOARD_DEFAULT_PORT}"
    local scheme="http"

    if [ -f "${DASHBOARD_PID_DIR}/host" ]; then
        host=$(cat "${DASHBOARD_PID_DIR}/host" 2>/dev/null)
    fi
    if [ -f "${DASHBOARD_PID_DIR}/port" ]; then
        port=$(cat "${DASHBOARD_PID_DIR}/port" 2>/dev/null)
    fi
    if [ -f "${DASHBOARD_PID_DIR}/scheme" ]; then
        scheme=$(cat "${DASHBOARD_PID_DIR}/scheme" 2>/dev/null)
    fi

    local url="${scheme}://${host}:${port}"

    echo -e "${GREEN}Opening dashboard: $url${NC}"

    # Open in browser (cross-platform)
    if command -v open &> /dev/null; then
        open "$url"
    elif command -v xdg-open &> /dev/null; then
        xdg-open "$url"
    elif command -v start &> /dev/null; then
        start "$url"
    else
        echo ""
        echo "Could not detect browser opener."
        echo "Please open in browser: $url"
    fi
}

# Import GitHub issues
cmd_import() {
    if [ ! -d "$LOKI_DIR" ]; then
        mkdir -p "$LOKI_DIR/queue"
    fi

    export LOKI_GITHUB_IMPORT=true

    # Check gh CLI
    if ! command -v gh &> /dev/null; then
        echo -e "${RED}Error: gh CLI not found. Install with: brew install gh${NC}"
        exit 1
    fi

    if ! gh auth status &> /dev/null; then
        echo -e "${RED}Error: gh CLI not authenticated. Run: gh auth login${NC}"
        exit 1
    fi

    echo -e "${GREEN}Importing GitHub issues...${NC}"
    # Source the functions from run.sh and call import
    source "$RUN_SH" 2>/dev/null || true
    if type import_github_issues &>/dev/null; then
        import_github_issues
    else
        echo -e "${YELLOW}Import function not available. Using fallback.${NC}"
        gh issue list --json number,title,url --limit 20
    fi
}

# GitHub integration management (v5.41.0)
cmd_github() {
    local subcmd="${1:-help}"
    shift 2>/dev/null || true

    case "$subcmd" in
        sync)
            # Sync completed tasks back to GitHub issues
            if [ ! -d "$LOKI_DIR" ]; then
                echo -e "${RED}No active Loki session found${NC}"
                exit 1
            fi

            if ! command -v gh &>/dev/null; then
                echo -e "${RED}Error: gh CLI not found. Install with: brew install gh${NC}"
                exit 1
            fi

            if ! gh auth status &>/dev/null; then
                echo -e "${RED}Error: gh CLI not authenticated. Run: gh auth login${NC}"
                exit 1
            fi

            export LOKI_GITHUB_SYNC=true
            source "$RUN_SH" 2>/dev/null || true

            echo -e "${GREEN}Syncing completed tasks to GitHub...${NC}"
            if type sync_github_completed_tasks &>/dev/null; then
                sync_github_completed_tasks
                echo -e "${GREEN}Sync complete.${NC}"

                # Show what was synced
                if [ -f "$LOKI_DIR/github/synced.log" ]; then
                    local count
                    count=$(wc -l < "$LOKI_DIR/github/synced.log" | tr -d ' ')
                    echo -e "${DIM}Total synced status updates: $count${NC}"
                fi
            else
                echo -e "${YELLOW}Sync function not available.${NC}"
            fi
            ;;

        export)
            # Export local tasks as GitHub issues
            if [ ! -d "$LOKI_DIR" ]; then
                echo -e "${RED}No active Loki session found${NC}"
                exit 1
            fi

            if ! command -v gh &>/dev/null; then
                echo -e "${RED}Error: gh CLI not found. Install with: brew install gh${NC}"
                exit 1
            fi

            echo -e "${GREEN}Exporting local tasks to GitHub issues...${NC}"
            source "$RUN_SH" 2>/dev/null || true
            if type export_tasks_to_github &>/dev/null; then
                export_tasks_to_github
                echo -e "${GREEN}Export complete.${NC}"
            else
                echo -e "${YELLOW}Export function not available.${NC}"
            fi
            ;;

        pr)
            # Create PR from completed work
            if ! command -v gh &>/dev/null; then
                echo -e "${RED}Error: gh CLI not found. Install with: brew install gh${NC}"
                exit 1
            fi

            local feature_name="${1:-Loki Mode changes}"
            export LOKI_GITHUB_PR=true
            source "$RUN_SH" 2>/dev/null || true

            echo -e "${GREEN}Creating pull request: $feature_name${NC}"
            if type create_github_pr &>/dev/null; then
                create_github_pr "$feature_name"
            else
                echo -e "${YELLOW}PR function not available.${NC}"
            fi
            ;;

        status)
            # Show GitHub integration status
            echo -e "${BOLD}GitHub Integration Status${NC}"
            echo ""

            # gh CLI
            if command -v gh &>/dev/null; then
                echo -e "  gh CLI:       ${GREEN}installed$(gh --version 2>/dev/null | head -1 | sed 's/gh version /v/')${NC}"
                if gh auth status &>/dev/null 2>&1; then
                    echo -e "  Auth:         ${GREEN}authenticated${NC}"
                else
                    echo -e "  Auth:         ${RED}not authenticated${NC}"
                fi
            else
                echo -e "  gh CLI:       ${RED}not installed${NC}"
            fi

            # Repo detection
            local repo=""
            repo=$(git remote get-url origin 2>/dev/null | sed 's|.*github.com[:/]||;s|\.git$||' || echo "")
            if [ -n "$repo" ]; then
                echo -e "  Repository:   ${GREEN}$repo${NC}"
            else
                echo -e "  Repository:   ${YELLOW}not detected${NC}"
            fi

            # Config flags
            echo ""
            echo -e "${BOLD}Configuration${NC}"
            echo -e "  LOKI_GITHUB_IMPORT:  ${LOKI_GITHUB_IMPORT:-false}"
            echo -e "  LOKI_GITHUB_SYNC:    ${LOKI_GITHUB_SYNC:-false}"
            echo -e "  LOKI_GITHUB_PR:      ${LOKI_GITHUB_PR:-false}"
            echo -e "  LOKI_GITHUB_LABELS:  ${LOKI_GITHUB_LABELS:-(all)}"
            echo -e "  LOKI_GITHUB_LIMIT:   ${LOKI_GITHUB_LIMIT:-100}"

            # Sync log
            if [ -f "$LOKI_DIR/github/synced.log" ]; then
                echo ""
                echo -e "${BOLD}Sync History${NC}"
                local total
                total=$(wc -l < "$LOKI_DIR/github/synced.log" | tr -d ' ')
                echo -e "  Total synced updates: $total"
                echo -e "  Recent:"
                tail -5 "$LOKI_DIR/github/synced.log" | sed 's/^/    /'
            fi

            # Imported tasks
            if [ -f "$LOKI_DIR/queue/pending.json" ]; then
                local gh_tasks
                gh_tasks=$(python3 -c "
import json
try:
    with open('$LOKI_DIR/queue/pending.json') as f:
        data = json.load(f)
    tasks = data.get('tasks', data) if isinstance(data, dict) else data
    gh = [t for t in tasks if t.get('source') == 'github']
    print(len(gh))
except: print(0)
" 2>/dev/null || echo "0")
                echo ""
                echo -e "${BOLD}Imported Issues${NC}"
                echo -e "  GitHub tasks in queue: $gh_tasks"
            fi
            ;;

        help|*)
            echo -e "${BOLD}loki github${NC} - GitHub integration management"
            echo ""
            echo "Commands:"
            echo "  status       Show GitHub integration status"
            echo "  sync         Sync completed task status back to GitHub issues"
            echo "  export       Export local tasks as new GitHub issues"
            echo "  pr [name]    Create pull request from completed work"
            echo ""
            echo "Environment Variables:"
            echo "  LOKI_GITHUB_IMPORT=true    Import open issues as tasks on start"
            echo "  LOKI_GITHUB_SYNC=true      Sync status back to issues during session"
            echo "  LOKI_GITHUB_PR=true        Create PR when session completes successfully"
            echo "  LOKI_GITHUB_LABELS=bug     Filter issues by label (comma-separated)"
            echo "  LOKI_GITHUB_MILESTONE=v2   Filter by milestone"
            echo "  LOKI_GITHUB_ASSIGNEE=me    Filter by assignee"
            echo "  LOKI_GITHUB_LIMIT=50       Max issues to import (default: 100)"
            echo "  LOKI_GITHUB_PR_LABEL=loki  Label to add to created PRs"
            echo ""
            echo "Examples:"
            echo "  loki github status"
            echo "  loki github sync"
            echo "  loki github export"
            echo "  loki github pr \"Add user authentication\""
            echo "  LOKI_GITHUB_SYNC=true loki start --github ./prd.md"
            ;;
    esac
}

# Parse GitHub issue using issue-parser.sh
cmd_issue_parse() {
    local issue_ref=""
    local format="yaml"
    local output_file=""
    local quiet=false

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --help|-h)
                echo -e "${BOLD}loki issue parse${NC} - Parse GitHub issue into structured format"
                echo ""
                echo "Usage: loki issue parse <issue-ref> [options]"
                echo ""
                echo "Issue Reference Formats:"
                echo "  https://github.com/owner/repo/issues/123"
                echo "  owner/repo#123"
                echo "  #123                  (uses current repo)"
                echo "  123                   (uses current repo)"
                echo ""
                echo "Options:"
                echo "  --format yaml|json    Output format (default: yaml)"
                echo "  --output FILE         Write to file instead of stdout"
                echo "  --quiet               Suppress info messages"
                echo ""
                echo "Examples:"
                echo "  loki issue parse 123"
                echo "  loki issue parse owner/repo#456 --format json"
                echo "  loki issue parse 789 --output issue.yaml"
                exit 0
                ;;
            --format)
                format="${2:-yaml}"
                if [ $# -ge 2 ]; then shift 2; else shift; fi
                ;;
            --format=*)
                format="${1#*=}"
                shift
                ;;
            --output|-o)
                output_file="${2:-}"
                if [ $# -ge 2 ]; then shift 2; else shift; fi
                ;;
            --output=*)
                output_file="${1#*=}"
                shift
                ;;
            --quiet|-q)
                quiet=true
                shift
                ;;
            -*)
                echo -e "${RED}Unknown option: $1${NC}"
                echo "Run 'loki issue parse --help' for usage."
                exit 1
                ;;
            *)
                if [[ -z "$issue_ref" ]]; then
                    issue_ref="$1"
                fi
                shift
                ;;
        esac
    done

    if [[ -z "$issue_ref" ]]; then
        echo -e "${RED}Error: Issue reference required${NC}"
        echo "Usage: loki issue parse <issue-ref>"
        exit 1
    fi

    # Find and run issue-parser.sh
    local parser_script="$SKILL_DIR/autonomy/issue-parser.sh"
    if [[ ! -f "$parser_script" ]]; then
        echo -e "${RED}Error: issue-parser.sh not found at $parser_script${NC}"
        exit 1
    fi

    local args=("$issue_ref" "--format" "$format")
    [[ -n "$output_file" ]] && args+=("--output" "$output_file")
    [[ "$quiet" == "true" ]] && args+=("--quiet")

    "$parser_script" "${args[@]}"
}

# View parsed GitHub issue details
cmd_issue_view() {
    require_jq

    local issue_ref="${1:-}"

    # Handle --help flag
    if [[ "$issue_ref" == "--help" || "$issue_ref" == "-h" ]]; then
        echo -e "${BOLD}loki issue view${NC} - View parsed GitHub issue details"
        echo ""
        echo "Usage: loki issue view <issue-ref>"
        echo ""
        echo "Issue Reference Formats:"
        echo "  https://github.com/owner/repo/issues/123"
        echo "  owner/repo#123"
        echo "  #123                  (uses current repo)"
        echo "  123                   (uses current repo)"
        echo ""
        echo "Examples:"
        echo "  loki issue view 123"
        echo "  loki issue view owner/repo#456"
        exit 0
    fi

    if [[ -z "$issue_ref" ]]; then
        echo -e "${RED}Error: Issue reference required${NC}"
        echo "Usage: loki issue view <issue-ref>"
        exit 1
    fi

    # Find and run issue-parser.sh
    local parser_script="$SKILL_DIR/autonomy/issue-parser.sh"
    if [[ ! -f "$parser_script" ]]; then
        echo -e "${RED}Error: issue-parser.sh not found at $parser_script${NC}"
        exit 1
    fi

    # Parse and get JSON for easier extraction
    local parsed_json
    parsed_json=$("$parser_script" "$issue_ref" --format json --quiet 2>&1)
    local exit_code=$?

    if [[ $exit_code -ne 0 ]]; then
        echo "$parsed_json"
        exit $exit_code
    fi

    # Extract fields using jq
    local title type priority labels url problem acceptance technical raw_body
    title=$(echo "$parsed_json" | jq -r '.metadata.title // ""')
    type=$(echo "$parsed_json" | jq -r '.metadata.type // "task"')
    priority=$(echo "$parsed_json" | jq -r '.metadata.priority // "normal"')
    labels=$(echo "$parsed_json" | jq -r '.metadata.labels | join(", ") // ""')
    url=$(echo "$parsed_json" | jq -r '.source.url // ""')
    problem=$(echo "$parsed_json" | jq -r '.content.problem_statement // ""')
    acceptance=$(echo "$parsed_json" | jq -r '.content.acceptance_criteria // ""')
    technical=$(echo "$parsed_json" | jq -r '.content.technical_requirements // ""')
    raw_body=$(echo "$parsed_json" | jq -r '.content.raw_body // ""')

    # Display structured view
    echo -e "${BOLD}GitHub Issue Details${NC}"
    echo ""
    echo ""

    echo -e "${CYAN}Title:${NC}    $title"
    echo -e "${CYAN}Type:${NC}     $type"
    echo -e "${CYAN}Priority:${NC} $priority"
    echo -e "${CYAN}Labels:${NC}   $labels"
    echo -e "${CYAN}URL:${NC}      $url"
    echo ""

    # Problem statement
    if [[ -n "$problem" ]]; then
        echo -e "${BOLD}Problem Statement${NC}"
        echo ""
        echo "$problem" | head -15
        echo ""
    fi

    # Acceptance criteria
    if [[ -n "$acceptance" && "$acceptance" != "null" ]]; then
        echo -e "${BOLD}Acceptance Criteria${NC}"
        echo ""
        echo "$acceptance" | head -15
        echo ""
    fi

    # Technical requirements
    if [[ -n "$technical" && "$technical" != "null" ]]; then
        echo -e "${BOLD}Technical Requirements${NC}"
        echo ""
        echo "$technical" | head -10
        echo ""
    fi

    # Show raw body preview if nothing else was extracted
    if [[ -z "$problem" && -z "$acceptance" && -z "$technical" && -n "$raw_body" ]]; then
        echo -e "${BOLD}Issue Body${NC}"
        echo ""
        echo "$raw_body" | head -20
        echo ""
    fi

    echo ""
    echo ""
    echo -e "Next steps:"
    echo -e "  ${CYAN}loki issue parse $issue_ref --format json${NC}  # Get JSON output"
    echo -e "  ${CYAN}loki issue $issue_ref --start${NC}              # Generate PRD and start"
}

# Generate PRD from GitHub issue
cmd_issue() {
    require_jq

    local issue_ref=""
    local repo=""
    local number=""
    local start_loki=false
    local dry_run=false
    local output_file=""
    local start_args=()
    local subcommand=""

    # Check for subcommands first
    if [[ $# -gt 0 ]]; then
        case "$1" in
            parse)
                # Delegate to issue-parser.sh
                shift
                cmd_issue_parse "$@"
                return $?
                ;;
            view)
                # View parsed issue details
                shift
                cmd_issue_view "$@"
                return $?
                ;;
        esac
    fi

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --help|-h)
                echo -e "${BOLD}loki issue${NC} - Generate PRD from GitHub issue"
                echo ""
                echo "Usage: loki issue <url-or-number> [options]"
                echo "       loki issue parse <url-or-number> [--format yaml|json]"
                echo "       loki issue view <url-or-number>"
                echo "       loki issue --repo owner/repo --number 123 [options]"
                echo ""
                echo "Subcommands:"
                echo "  parse              Parse issue and output structured YAML/JSON"
                echo "  view               View parsed issue details"
                echo ""
                echo "Arguments:"
                echo "  <url-or-number>    GitHub issue URL or issue number"
                echo ""
                echo "Options:"
                echo "  --repo OWNER/REPO  Specify repository (default: auto-detect from git)"
                echo "  --number NUM       Specify issue number (alternative to positional arg)"
                echo "  --start            Start Loki Mode with the generated PRD"
                echo "  --dry-run          Preview generated PRD without saving"
                echo "  --output FILE      Save PRD to custom path (default: .loki/prd-issue-N.md)"
                echo ""
                echo "Options passed to 'start' (when --start is used):"
                echo "  --provider NAME    AI provider: claude (default), codex, gemini"
                echo "  --parallel         Enable parallel mode with git worktrees"
                echo "  --bg, --background Run in background mode"
                echo ""
                echo "Examples:"
                echo "  loki issue 123                           # Generate PRD from issue #123"
                echo "  loki issue 123 --dry-run                 # Preview without saving"
                echo "  loki issue 123 --start                   # Generate and start Loki Mode"
                echo "  loki issue 123 --start --parallel        # Generate, start in parallel mode"
                echo "  loki issue parse owner/repo#123          # Parse and output structured data"
                echo "  loki issue parse 123 --format json       # Parse and output JSON"
                echo "  loki issue view 123                      # View parsed issue details"
                echo "  loki issue --repo org/repo --number 456  # Specify repo and issue"
                echo "  loki issue https://github.com/org/repo/issues/789"
                exit 0
                ;;
            --repo)
                if [[ -n "${2:-}" ]]; then
                    repo="$2"
                    # Validate owner/repo format
                    if [[ ! "$repo" =~ ^[a-zA-Z0-9._-]+/[a-zA-Z0-9._-]+$ ]]; then
                        echo -e "${RED}Invalid --repo format: $repo${NC}"
                        echo "Expected: owner/repo (e.g., asklokesh/loki-mode)"
                        exit 1
                    fi
                    shift 2
                else
                    echo -e "${RED}--repo requires a value (owner/repo)${NC}"
                    exit 1
                fi
                ;;
            --repo=*)
                repo="${1#*=}"
                # Validate owner/repo format
                if [[ ! "$repo" =~ ^[a-zA-Z0-9._-]+/[a-zA-Z0-9._-]+$ ]]; then
                    echo -e "${RED}Invalid --repo format: $repo${NC}"
                    echo "Expected: owner/repo (e.g., asklokesh/loki-mode)"
                    exit 1
                fi
                shift
                ;;
            --number)
                if [[ -n "${2:-}" ]]; then
                    number="$2"
                    # Validate numeric
                    if [[ ! "$number" =~ ^[0-9]+$ ]]; then
                        echo -e "${RED}Invalid --number value: $number${NC}"
                        echo "Expected: numeric issue number (e.g., 123)"
                        exit 1
                    fi
                    shift 2
                else
                    echo -e "${RED}--number requires a value${NC}"
                    exit 1
                fi
                ;;
            --number=*)
                number="${1#*=}"
                # Validate numeric
                if [[ ! "$number" =~ ^[0-9]+$ ]]; then
                    echo -e "${RED}Invalid --number value: $number${NC}"
                    echo "Expected: numeric issue number (e.g., 123)"
                    exit 1
                fi
                shift
                ;;
            --start)
                start_loki=true
                shift
                ;;
            --dry-run)
                dry_run=true
                shift
                ;;
            --output)
                if [[ -n "${2:-}" ]]; then
                    output_file="$2"
                    shift 2
                else
                    echo -e "${RED}--output requires a file path${NC}"
                    exit 1
                fi
                ;;
            --output=*)
                output_file="${1#*=}"
                shift
                ;;
            # Pass through options to start command
            --provider|--parallel|--bg|--background|--simple|--complex|--github|--no-dashboard|--sandbox)
                start_args+=("$1")
                if [[ "$1" == "--provider" && -n "${2:-}" ]]; then
                    start_args+=("$2")
                    shift
                fi
                shift
                ;;
            -*)
                echo -e "${RED}Unknown option: $1${NC}"
                echo "Run 'loki issue --help' for usage."
                exit 1
                ;;
            *)
                issue_ref="$1"
                shift
                ;;
        esac
    done

    # Check gh CLI
    if ! command -v gh &> /dev/null; then
        echo -e "${RED}Error: gh CLI not found${NC}"
        echo "Install with: brew install gh"
        exit 1
    fi

    if ! gh auth status &> /dev/null 2>&1; then
        echo -e "${RED}Error: gh CLI not authenticated${NC}"
        echo "Run: gh auth login"
        exit 1
    fi

    # Parse issue reference
    if [[ -n "$issue_ref" ]]; then
        # Check if it's a URL
        if [[ "$issue_ref" =~ ^https?://github\.com/([^/]+/[^/]+)/issues/([0-9]+) ]]; then
            repo="${BASH_REMATCH[1]}"
            number="${BASH_REMATCH[2]}"
        elif [[ "$issue_ref" =~ ^([^/]+/[^/]+)#([0-9]+)$ ]]; then
            # owner/repo#number format
            repo="${BASH_REMATCH[1]}"
            number="${BASH_REMATCH[2]}"
        elif [[ "$issue_ref" =~ ^#?([0-9]+)$ ]]; then
            # Just a number (with optional #)
            number="${BASH_REMATCH[1]}"
        else
            echo -e "${RED}Invalid issue reference: $issue_ref${NC}"
            echo "Expected: issue number (123), owner/repo#123, or GitHub URL"
            exit 1
        fi
    fi

    # Validate we have a number
    if [[ -z "$number" ]]; then
        echo -e "${RED}Error: No issue number specified${NC}"
        echo "Usage: loki issue <number> or loki issue --number <number>"
        echo "Run 'loki issue --help' for full usage."
        exit 1
    fi

    # Auto-detect repo if not specified
    if [[ -z "$repo" ]]; then
        # Try to get from gh CLI (uses git remote)
        repo=$(gh repo view --json nameWithOwner -q '.nameWithOwner' 2>/dev/null) || true
        if [[ -z "$repo" ]]; then
            echo -e "${RED}Error: Could not determine repository${NC}"
            echo "Specify with: --repo owner/repo"
            echo "Or run from a directory with a GitHub remote configured."
            exit 1
        fi
    fi

    echo -e "${CYAN}Fetching issue #$number from $repo...${NC}"

    # Fetch issue details
    local issue_json
    if ! issue_json=$(gh issue view "$number" --repo "$repo" --json number,title,body,labels,milestone,author,createdAt,url 2>&1); then
        echo -e "${RED}Error fetching issue: $issue_json${NC}"
        exit 1
    fi

    # Extract fields
    local title body labels milestone author created_at issue_url
    title=$(echo "$issue_json" | jq -r '.title')
    body=$(echo "$issue_json" | jq -r '.body // ""')
    labels=$(echo "$issue_json" | jq -r '[.labels[].name] | join(", ") // ""')
    milestone=$(echo "$issue_json" | jq -r '.milestone.title // ""')
    author=$(echo "$issue_json" | jq -r '.author.login // ""')
    created_at=$(echo "$issue_json" | jq -r '.createdAt // ""')
    issue_url=$(echo "$issue_json" | jq -r '.url')

    # Generate PRD content
    local prd_content
    prd_content=$(cat <<EOF
# PRD: $title

**Source:** GitHub Issue [#$number]($issue_url)
**Author:** @$author
**Created:** $created_at
$([ -n "$labels" ] && echo "**Labels:** $labels")
$([ -n "$milestone" ] && echo "**Milestone:** $milestone")

---

## Overview

$body

---

## Acceptance Criteria

Based on the issue description, implement the following:

1. Address all requirements specified in the issue body above
2. Ensure backward compatibility (unless explicitly breaking changes are requested)
3. Add appropriate tests for new functionality
4. Update documentation as needed

---

## Technical Notes

- Source: GitHub Issue #$number
- Repository: $repo
- Generated by: Loki Mode CLI

---

## References

- Original Issue: $issue_url
EOF
)

    # Handle dry-run
    if [[ "$dry_run" == "true" ]]; then
        echo ""
        echo -e "${BOLD}Generated PRD Preview:${NC}"
        echo ""
        echo "$prd_content"
        echo ""
        echo ""
        echo -e "${DIM}(dry-run mode - PRD not saved)${NC}"
        exit 0
    fi

    # Determine output file
    if [[ -z "$output_file" ]]; then
        mkdir -p "$LOKI_DIR"
        output_file="$LOKI_DIR/prd-issue-$number.md"
    fi

    # Write PRD file
    echo "$prd_content" > "$output_file"
    echo -e "${GREEN}PRD generated: $output_file${NC}"

    # Fetch comments if any exist
    local comments_count
    comments_count=$(gh issue view "$number" --repo "$repo" --json comments -q '.comments | length' 2>/dev/null) || comments_count=0

    if [[ "$comments_count" -gt 0 ]]; then
        echo -e "${DIM}Issue has $comments_count comment(s) - view with: gh issue view $number --repo $repo${NC}"
    fi

    # Start Loki Mode if requested
    if [[ "$start_loki" == "true" ]]; then
        echo ""
        echo -e "${GREEN}Starting Loki Mode with generated PRD...${NC}"
        cmd_start "$output_file" ${start_args[@]+"${start_args[@]}"}
    else
        echo ""
        echo "Next steps:"
        echo -e "  ${CYAN}loki start $output_file${NC}           # Start Loki Mode with this PRD"
        echo -e "  ${CYAN}loki issue $number --start${NC}        # Or re-run with --start flag"
        echo -e "  ${DIM}cat $output_file${NC}  # View the generated PRD"
    fi
}

# Show configuration
cmd_config() {
    local subcommand="${1:-show}"

    case "$subcommand" in
        show)
            cmd_config_show
            ;;
        init)
            cmd_config_init
            ;;
        edit)
            cmd_config_edit
            ;;
        path)
            cmd_config_path
            ;;
        *)
            echo -e "${YELLOW}Usage: loki config [show|init|edit|path]${NC}"
            echo ""
            echo "  show   Show current configuration (default)"
            echo "  init   Create a config file from template"
            echo "  edit   Open config file in editor"
            echo "  path   Show config file paths"
            ;;
    esac
}

cmd_config_show() {
    echo -e "${BOLD}Loki Mode Configuration${NC}"
    echo ""
    echo -e "${CYAN}Installation:${NC} $SKILL_DIR"
    echo -e "${CYAN}Version:${NC} $(get_version)"
    echo ""

    # Check for config files
    local config_file=""
    if [ -f ".loki/config.yaml" ]; then
        config_file=".loki/config.yaml"
        echo -e "${GREEN}Config file:${NC} $config_file (project-local)"
    elif [ -f ".loki/config.yml" ]; then
        config_file=".loki/config.yml"
        echo -e "${GREEN}Config file:${NC} $config_file (project-local)"
    elif [ -f "${HOME}/.config/loki-mode/config.yaml" ]; then
        config_file="${HOME}/.config/loki-mode/config.yaml"
        echo -e "${GREEN}Config file:${NC} $config_file (user-global)"
    elif [ -f "${HOME}/.config/loki-mode/config.yml" ]; then
        config_file="${HOME}/.config/loki-mode/config.yml"
        echo -e "${GREEN}Config file:${NC} $config_file (user-global)"
    else
        echo -e "${YELLOW}Config file:${NC} Not found (using defaults)"
    fi
    echo ""

    echo -e "${CYAN}Current Settings:${NC}"
    echo ""
    echo "Core:"
    echo "  max_retries:      ${LOKI_MAX_RETRIES:-50}"
    echo "  base_wait:        ${LOKI_BASE_WAIT:-60}s"
    echo "  max_wait:         ${LOKI_MAX_WAIT:-3600}s"
    echo ""
    echo "Dashboard:"
    echo "  enabled:          ${LOKI_DASHBOARD:-true}"
    echo "  port:             ${LOKI_DASHBOARD_PORT:-57374}"
    echo ""
    echo "Notifications:"
    echo "  enabled:          ${LOKI_NOTIFICATIONS:-true}"
    echo "  sound:            ${LOKI_NOTIFICATION_SOUND:-true}"
    echo ""
    echo "GitHub Integration:"
    echo "  import:           ${LOKI_GITHUB_IMPORT:-false}"
    echo "  pr:               ${LOKI_GITHUB_PR:-false}"
    echo "  sync:             ${LOKI_GITHUB_SYNC:-false}"
    echo ""
    echo "Provider:"
    echo "  provider:         ${LOKI_PROVIDER:-claude}"
    echo ""
    echo "Execution:"
    echo "  complexity:       ${LOKI_COMPLEXITY:-auto}"
    echo "  parallel_mode:    ${LOKI_PARALLEL_MODE:-false}"
    echo "  max_iterations:   ${LOKI_MAX_ITERATIONS:-1000}"
    echo "  autonomy_mode:    ${LOKI_AUTONOMY_MODE:-perpetual}"
    echo ""
    echo -e "Run ${CYAN}loki config path${NC} to see all config file locations"
}

cmd_config_init() {
    local template="$SKILL_DIR/autonomy/config.example.yaml"
    local target=".loki/config.yaml"
    local global_target="${HOME}/.config/loki-mode/config.yaml"

    if [ ! -f "$template" ]; then
        echo -e "${RED}Error: Config template not found at $template${NC}"
        exit 1
    fi

    echo -e "${BOLD}Initialize Configuration${NC}"
    echo ""
    echo "Where do you want to create the config file?"
    echo ""
    echo "  1) $target (project-local, recommended)"
    echo "  2) $global_target (user-global)"
    echo ""
    read -p "Choice [1]: " choice
    choice="${choice:-1}"

    case "$choice" in
        1)
            mkdir -p ".loki"
            cp "$template" "$target"
            echo -e "${GREEN}Created: $target${NC}"
            ;;
        2)
            mkdir -p "${HOME}/.config/loki-mode"
            cp "$template" "$global_target"
            echo -e "${GREEN}Created: $global_target${NC}"
            ;;
        *)
            echo -e "${RED}Invalid choice${NC}"
            exit 1
            ;;
    esac

    echo ""
    echo "Edit with: loki config edit"
}

cmd_config_edit() {
    local config_file=""

    # Find existing config file
    if [ -f ".loki/config.yaml" ]; then
        config_file=".loki/config.yaml"
    elif [ -f ".loki/config.yml" ]; then
        config_file=".loki/config.yml"
    elif [ -f "${HOME}/.config/loki-mode/config.yaml" ]; then
        config_file="${HOME}/.config/loki-mode/config.yaml"
    elif [ -f "${HOME}/.config/loki-mode/config.yml" ]; then
        config_file="${HOME}/.config/loki-mode/config.yml"
    fi

    if [ -z "$config_file" ]; then
        echo -e "${YELLOW}No config file found.${NC}"
        read -p "Create one? [Y/n]: " create
        create="${create:-Y}"
        if [[ "$create" =~ ^[Yy] ]]; then
            cmd_config_init
            config_file=".loki/config.yaml"
        else
            exit 0
        fi
    fi

    # Open in editor
    local editor="${EDITOR:-${VISUAL:-vim}}"
    echo -e "${GREEN}Opening $config_file with $editor${NC}"
    "$editor" "$config_file"
}

cmd_config_path() {
    echo -e "${BOLD}Config File Search Paths${NC}"
    echo ""
    echo "Loki Mode searches for config files in this order:"
    echo ""

    local paths=(
        ".loki/config.yaml"
        ".loki/config.yml"
        "${HOME}/.config/loki-mode/config.yaml"
        "${HOME}/.config/loki-mode/config.yml"
    )

    for path in "${paths[@]}"; do
        if [ -f "$path" ]; then
            echo -e "  ${GREEN}[FOUND]${NC}  $path"
        else
            echo -e "  ${YELLOW}[-----]${NC}  $path"
        fi
    done

    echo ""
    echo "Template: $SKILL_DIR/autonomy/config.example.yaml"
    echo ""
    echo "Create a config file with: loki config init"
}

# Check system prerequisites
cmd_doctor() {
    local json_output=false

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --json)
                json_output=true
                shift
                ;;
            --help|-h)
                echo -e "${BOLD}loki doctor${NC} - Check system prerequisites"
                echo ""
                echo "Usage: loki doctor [--json]"
                echo ""
                echo "Options:"
                echo "  --json    Output machine-readable JSON"
                echo ""
                echo "Checks: node, python3, jq, git, curl, bash version,"
                echo "        claude/codex/gemini CLIs, and disk space."
                return 0
                ;;
            *)
                echo -e "${RED}Unknown option: $1${NC}"
                echo "Usage: loki doctor [--json]"
                return 1
                ;;
        esac
    done

    if [ "$json_output" = true ]; then
        cmd_doctor_json
        return $?
    fi

    echo -e "${BOLD}Loki Mode Doctor${NC}"
    echo ""
    echo "Checking system prerequisites..."
    echo ""

    local pass_count=0
    local fail_count=0
    local warn_count=0

    # Helper: check command exists and optionally check version
    doctor_check() {
        local name="$1"
        local cmd="$2"
        local required="$3"  # required, recommended, optional
        local min_version="${4:-}"

        if ! command -v "$cmd" &> /dev/null; then
            if [ "$required" = "required" ]; then
                echo -e "  ${RED}FAIL${NC}  $name - not found"
                fail_count=$((fail_count + 1))
            elif [ "$required" = "recommended" ]; then
                echo -e "  ${YELLOW}WARN${NC}  $name - not found (recommended)"
                warn_count=$((warn_count + 1))
            else
                echo -e "  ${YELLOW}WARN${NC}  $name - not found (optional)"
                warn_count=$((warn_count + 1))
            fi
            return 1
        fi

        local version=""
        case "$cmd" in
            node)
                version=$(node --version 2>/dev/null | tr -d 'v')
                ;;
            python3)
                version=$(python3 --version 2>/dev/null | awk '{print $2}')
                ;;
            git)
                version=$(git --version 2>/dev/null | awk '{print $3}')
                ;;
            bash)
                version=$("$cmd" --version 2>/dev/null | head -1 | sed 's/.*version \([0-9.]*\).*/\1/')
                ;;
            jq)
                version=$(jq --version 2>/dev/null | tr -d 'jq-')
                ;;
            curl)
                version=$(curl --version 2>/dev/null | head -1 | awk '{print $2}')
                ;;
            claude)
                version=$(claude --version 2>/dev/null | head -1 | sed 's/[^0-9.]//g' | head -1)
                ;;
            codex)
                version=$(codex --version 2>/dev/null | head -1 | sed 's/[^0-9.]//g' | head -1)
                ;;
            gemini)
                version=$(gemini --version 2>/dev/null | head -1 | sed 's/[^0-9.]//g' | head -1)
                ;;
        esac

        local version_display=""
        if [ -n "$version" ]; then
            version_display=" (v$version)"
        fi

        # Simple major version check if min_version is specified
        if [ -n "$min_version" ] && [ -n "$version" ]; then
            local cur_major cur_minor min_major min_minor
            cur_major=$(echo "$version" | cut -d. -f1)
            min_major=$(echo "$min_version" | cut -d. -f1)
            cur_minor=$(echo "$version" | cut -d. -f2)
            min_minor=$(echo "$min_version" | cut -d. -f2)

            if [ "$cur_major" -lt "$min_major" ] 2>/dev/null || \
               { [ "$cur_major" -eq "$min_major" ] 2>/dev/null && [ "$cur_minor" -lt "$min_minor" ] 2>/dev/null; }; then
                if [ "$required" = "required" ]; then
                    echo -e "  ${RED}FAIL${NC}  $name$version_display - requires >= $min_version"
                    fail_count=$((fail_count + 1))
                else
                    echo -e "  ${YELLOW}WARN${NC}  $name$version_display - recommended >= $min_version"
                    warn_count=$((warn_count + 1))
                fi
                return 1
            fi
        fi

        echo -e "  ${GREEN}PASS${NC}  $name$version_display"
        pass_count=$((pass_count + 1))
        return 0
    }

    echo -e "${CYAN}Required:${NC}"
    doctor_check "Node.js (>= 18)"    node     required    18.0
    doctor_check "Python 3 (>= 3.8)"  python3  required    3.8
    doctor_check "jq"                  jq       required
    doctor_check "git"                 git      required
    doctor_check "curl"                curl     required
    echo ""

    echo -e "${CYAN}AI Providers:${NC}"
    doctor_check "Claude CLI"          claude   optional
    doctor_check "Codex CLI"           codex    optional
    doctor_check "Gemini CLI"          gemini   optional
    echo ""

    echo -e "${CYAN}System:${NC}"
    doctor_check "bash (>= 4.0)"      bash     recommended  4.0

    # Disk space check
    local disk_avail
    if command -v df &> /dev/null; then
        # Get available space in GB (works on macOS and Linux)
        disk_avail=$(df -g "$HOME" 2>/dev/null | tail -1 | awk '{print $4}')
        if [ -z "$disk_avail" ]; then
            # Linux fallback (df -g may not work)
            disk_avail=$(df -BG "$HOME" 2>/dev/null | tail -1 | awk '{print $4}' | tr -d 'G')
        fi
        if [ -n "$disk_avail" ] && [ "$disk_avail" -gt 0 ] 2>/dev/null; then
            if [ "$disk_avail" -lt 1 ]; then
                echo -e "  ${RED}FAIL${NC}  Disk space: ${disk_avail}GB available (need >= 1GB)"
                fail_count=$((fail_count + 1))
            elif [ "$disk_avail" -lt 5 ]; then
                echo -e "  ${YELLOW}WARN${NC}  Disk space: ${disk_avail}GB available (low)"
                warn_count=$((warn_count + 1))
            else
                echo -e "  ${GREEN}PASS${NC}  Disk space: ${disk_avail}GB available"
                pass_count=$((pass_count + 1))
            fi
        else
            echo -e "  ${YELLOW}WARN${NC}  Disk space: unable to determine"
            warn_count=$((warn_count + 1))
        fi
    fi
    echo ""

    # Summary
    echo -e "${BOLD}Summary:${NC} ${GREEN}$pass_count passed${NC}, ${RED}$fail_count failed${NC}, ${YELLOW}$warn_count warnings${NC}"
    echo ""

    if [ "$fail_count" -gt 0 ]; then
        echo -e "${RED}Some required prerequisites are missing.${NC}"
        echo "Install missing dependencies and run 'loki doctor' again."
        return 1
    elif [ "$warn_count" -gt 0 ]; then
        echo -e "${YELLOW}All required checks passed with some warnings.${NC}"
        return 0
    else
        echo -e "${GREEN}All checks passed. System is ready for Loki Mode.${NC}"
        return 0
    fi
}

# JSON output for loki doctor --json
cmd_doctor_json() {
    python3 -c "
import json, os, subprocess, sys, shutil

def get_version(cmd, args=None):
    try:
        if args is None:
            args = ['--version']
        result = subprocess.run([cmd] + args, capture_output=True, text=True, timeout=5)
        output = result.stdout.strip() or result.stderr.strip()
        # Extract version number
        import re
        match = re.search(r'(\d+\.\d+[\.\d]*)', output)
        return match.group(1) if match else None
    except (FileNotFoundError, subprocess.TimeoutExpired, Exception):
        return None

def check_tool(name, cmd, required, min_version=None):
    found = shutil.which(cmd) is not None
    version = get_version(cmd) if found else None
    status = 'pass'

    if not found:
        status = 'fail' if required == 'required' else 'warn'
    elif min_version and version:
        cur_parts = [int(x) for x in version.split('.')[:2]]
        min_parts = [int(x) for x in min_version.split('.')[:2]]
        while len(cur_parts) < 2: cur_parts.append(0)
        while len(min_parts) < 2: min_parts.append(0)
        if cur_parts < min_parts:
            status = 'fail' if required == 'required' else 'warn'

    return {
        'name': name,
        'command': cmd,
        'found': found,
        'version': version,
        'required': required,
        'min_version': min_version,
        'status': status,
        'path': shutil.which(cmd)
    }

checks = []
checks.append(check_tool('Node.js', 'node', 'required', '18.0'))
checks.append(check_tool('Python 3', 'python3', 'required', '3.8'))
checks.append(check_tool('jq', 'jq', 'required'))
checks.append(check_tool('git', 'git', 'required'))
checks.append(check_tool('curl', 'curl', 'required'))
checks.append(check_tool('bash', 'bash', 'recommended', '4.0'))
checks.append(check_tool('Claude CLI', 'claude', 'optional'))
checks.append(check_tool('Codex CLI', 'codex', 'optional'))
checks.append(check_tool('Gemini CLI', 'gemini', 'optional'))

# Disk space
disk_gb = None
try:
    stat = os.statvfs(os.path.expanduser('~'))
    disk_gb = round((stat.f_bavail * stat.f_frsize) / (1024**3), 1)
except Exception:
    pass

disk_status = 'pass'
if disk_gb is not None:
    if disk_gb < 1:
        disk_status = 'fail'
    elif disk_gb < 5:
        disk_status = 'warn'

pass_count = sum(1 for c in checks if c['status'] == 'pass')
fail_count = sum(1 for c in checks if c['status'] == 'fail')
warn_count = sum(1 for c in checks if c['status'] == 'warn')

if disk_status == 'pass': pass_count += 1
elif disk_status == 'fail': fail_count += 1
elif disk_status == 'warn': warn_count += 1

result = {
    'checks': checks,
    'disk': {
        'available_gb': disk_gb,
        'status': disk_status
    },
    'summary': {
        'passed': pass_count,
        'failed': fail_count,
        'warnings': warn_count,
        'ok': fail_count == 0
    }
}

print(json.dumps(result, indent=2))
"
}

# Show version
cmd_version() {
    echo "Loki Mode v$(get_version)"
}

# Secrets / credential management
cmd_secrets() {
    case "${1:-status}" in
        status)
            echo "API Key Status:"
            echo ""
            for key_var in ANTHROPIC_API_KEY OPENAI_API_KEY GOOGLE_API_KEY; do
                local value="${!key_var:-}"
                if [[ -n "$value" ]]; then
                    local masked="${value:0:8}...${value: -4}"
                    echo "  $key_var: SET ($masked, ${#value} chars)"
                else
                    # Check secret file mounts
                    local lower_name
                    lower_name=$(echo "$key_var" | tr '[:upper:]' '[:lower:]')
                    local found=false
                    for mount_path in /run/secrets /var/run/secrets; do
                        if [[ -f "$mount_path/$lower_name" ]]; then
                            echo "  $key_var: AVAILABLE (secret file: $mount_path/$lower_name)"
                            found=true
                            break
                        fi
                    done
                    if [[ "$found" != "true" ]]; then
                        echo "  $key_var: NOT SET"
                    fi
                fi
            done
            ;;
        validate)
            echo "Validating API keys..."
            python3 -c "
import sys
sys.path.insert(0, '$(dirname "$(dirname "$(resolve_script_path "$0")")")')
from dashboard.secrets import load_secrets
result = load_secrets()
for name, info in result.items():
    status = 'OK' if info['valid_format'] else 'INVALID'
    source = info['source']
    masked = info['masked']
    warning = info.get('warning', '')
    if info['set']:
        print(f'  {name}: {status} ({masked}, source: {source})')
        if warning:
            print(f'    WARNING: {warning}')
    else:
        print(f'  {name}: NOT SET')
" 2>/dev/null || echo "  (Python validation unavailable, showing basic status)"
            ;;
        help)
            echo "Usage: loki secrets [status|validate|help]"
            echo ""
            echo "Manage API keys and credentials."
            echo ""
            echo "Commands:"
            echo "  status    Show which API keys are configured (default)"
            echo "  validate  Validate API key formats"
            echo "  help      Show this help"
            echo ""
            echo "Secret Loading Priority:"
            echo "  1. Environment variable (ANTHROPIC_API_KEY, etc.)"
            echo "  2. Docker/K8s secret file (/run/secrets/anthropic_api_key)"
            echo "  3. Not set"
            ;;
        *)
            echo "Unknown secrets command: $1"
            cmd_secrets help
            return 1
            ;;
    esac
}

# Show recent logs
cmd_logs() {
    local lines="${1:-50}"
    local log_file="$LOKI_DIR/logs/session.log"

    if [ ! -f "$log_file" ]; then
        echo -e "${YELLOW}No log file found at $log_file${NC}"
        exit 0
    fi

    echo -e "${BOLD}Recent Logs (last $lines lines)${NC}"
    echo ""
    tail -n "$lines" "$log_file"
}

# API server management (delegates to unified FastAPI dashboard server)
cmd_api() {
    local subcommand="${1:-help}"
    local port="${LOKI_DASHBOARD_PORT:-57374}"
    local pid_file="$LOKI_DIR/dashboard/dashboard.pid"

    case "$subcommand" in
        start)
            # Check if Python is available
            if ! command -v python3 &> /dev/null; then
                echo -e "${RED}Error: Python 3 not found. Install with: brew install python3${NC}"
                exit 1
            fi

            # Check if already running
            if [ -f "$pid_file" ]; then
                local existing_pid=$(cat "$pid_file")
                if kill -0 "$existing_pid" 2>/dev/null; then
                    echo -e "${YELLOW}Dashboard server already running (PID: $existing_pid)${NC}"
                    echo "URL: http://localhost:$port"
                    exit 0
                fi
            fi

            # Start server
            mkdir -p "$LOKI_DIR/logs" "$LOKI_DIR/dashboard"
            local uvicorn_args="--host 0.0.0.0 --port $port"
            if [ -n "${LOKI_TLS_CERT:-}" ] && [ -n "${LOKI_TLS_KEY:-}" ]; then
                uvicorn_args="$uvicorn_args --ssl-certfile ${LOKI_TLS_CERT} --ssl-keyfile ${LOKI_TLS_KEY}"
            fi
            LOKI_DIR="$LOKI_DIR" nohup python3 -m uvicorn dashboard.server:app $uvicorn_args > "$LOKI_DIR/logs/api.log" 2>&1 &
            local new_pid=$!
            echo "$new_pid" > "$pid_file"

            echo -e "${GREEN}Dashboard server started${NC}"
            echo "  PID:  $new_pid"
            echo "  URL:  http://localhost:$port"
            echo "  Logs: $LOKI_DIR/logs/api.log"
            ;;

        stop)
            if [ -f "$pid_file" ]; then
                local pid=$(cat "$pid_file")
                if kill -0 "$pid" 2>/dev/null; then
                    kill "$pid"
                    rm -f "$pid_file"
                    echo -e "${GREEN}Dashboard server stopped${NC}"
                else
                    rm -f "$pid_file"
                    echo -e "${YELLOW}Dashboard server was not running${NC}"
                fi
            else
                echo -e "${YELLOW}No dashboard server PID file found${NC}"
            fi
            ;;

        status)
            if [ -f "$pid_file" ]; then
                local pid=$(cat "$pid_file")
                if kill -0 "$pid" 2>/dev/null; then
                    echo -e "${GREEN}Dashboard server running${NC}"
                    echo "  PID:  $pid"
                    echo "  URL:  http://localhost:$port"

                    # Try to fetch status
                    if command -v curl &> /dev/null; then
                        echo ""
                        echo -e "${CYAN}Status:${NC}"
                        curl -s "http://localhost:$port/api/status" 2>/dev/null | jq . 2>/dev/null || true
                    fi
                else
                    echo -e "${YELLOW}Dashboard server not running (stale PID file)${NC}"
                    rm -f "$pid_file"
                fi
            else
                echo -e "${YELLOW}Dashboard server not running${NC}"
            fi
            ;;

        *)
            echo -e "${BOLD}Loki Mode Dashboard/API Server${NC}"
            echo ""
            echo "Usage: loki api <command>"
            echo ""
            echo "Commands:"
            echo "  start    Start the unified FastAPI dashboard server"
            echo "  stop     Stop the dashboard server"
            echo "  status   Check if dashboard server is running"
            echo ""
            echo "Environment:"
            echo "  LOKI_DASHBOARD_PORT  Port to listen on (default: 57374)"
            echo ""
            echo "Endpoints:"
            echo "  GET  /api/health  - Health check"
            echo "  GET  /api/status  - Session status"
            echo "  GET  /api/events  - SSE stream"
            echo "  GET  /api/logs    - Recent logs"
            echo "  POST /api/start   - Start session"
            echo "  POST /api/stop    - Stop session"
            echo "  POST /api/pause   - Pause session"
            echo "  POST /api/resume  - Resume session"
            ;;
    esac
}

# Multi-channel notifications (Slack, Discord, Webhook)
cmd_notify() {
    local subcommand="${1:-help}"
    shift || true

    case "$subcommand" in
        test)
            cmd_notify_test "$@"
            ;;
        slack)
            cmd_notify_send "slack" "$@"
            ;;
        discord)
            cmd_notify_send "discord" "$@"
            ;;
        webhook)
            cmd_notify_send "webhook" "$@"
            ;;
        status)
            cmd_notify_status
            ;;
        --help|-h|help)
            cmd_notify_help
            ;;
        *)
            # If first arg looks like a message, treat as test
            if [[ "$subcommand" != -* ]]; then
                cmd_notify_test "$subcommand" "$@"
            else
                echo -e "${RED}Unknown notify command: $subcommand${NC}"
                echo "Run 'loki notify help' for usage."
                exit 1
            fi
            ;;
    esac
}

cmd_notify_help() {
    echo -e "${BOLD}Loki Mode Notifications${NC}"
    echo ""
    echo "Usage: loki notify <command> [message]"
    echo ""
    echo "Commands:"
    echo "  test [message]     Send test notification to all configured channels"
    echo "  slack <message>    Send notification to Slack only"
    echo "  discord <message>  Send notification to Discord only"
    echo "  webhook <message>  Send notification to webhook only"
    echo "  status             Show which notification channels are configured"
    echo "  help               Show this help"
    echo ""
    echo "Environment Variables:"
    echo "  LOKI_SLACK_WEBHOOK    Slack incoming webhook URL"
    echo "  LOKI_DISCORD_WEBHOOK  Discord webhook URL"
    echo "  LOKI_WEBHOOK_URL      Custom webhook URL (POST JSON)"
    echo "  LOKI_NOTIFY_CHANNELS  Channels to use (comma-separated: slack,discord,webhook)"
    echo "                        Default: all configured channels"
    echo ""
    echo "Examples:"
    echo "  loki notify test                    # Test all configured channels"
    echo "  loki notify test 'Hello World'     # Test with custom message"
    echo "  loki notify slack 'Build complete' # Send to Slack only"
    echo "  loki notify status                 # Check configuration"
    echo ""
    echo "Configuration via .loki/config.yaml:"
    echo "  notifications:"
    echo "    slack_webhook: https://hooks.slack.com/services/..."
    echo "    discord_webhook: https://discord.com/api/webhooks/..."
    echo "    webhook_url: https://your-server.com/webhook"
    echo "    channels: slack,discord  # or 'all'"
}

cmd_notify_status() {
    echo -e "${BOLD}Notification Channel Status${NC}"
    echo ""

    local any_configured=false

    # Check Slack
    if [ -n "${LOKI_SLACK_WEBHOOK:-}" ]; then
        echo -e "  ${GREEN}[OK]${NC} Slack     - Configured"
        any_configured=true
    else
        echo -e "  ${DIM}[--]${NC} Slack     - Not configured (set LOKI_SLACK_WEBHOOK)"
    fi

    # Check Discord
    if [ -n "${LOKI_DISCORD_WEBHOOK:-}" ]; then
        echo -e "  ${GREEN}[OK]${NC} Discord   - Configured"
        any_configured=true
    else
        echo -e "  ${DIM}[--]${NC} Discord   - Not configured (set LOKI_DISCORD_WEBHOOK)"
    fi

    # Check custom webhook
    if [ -n "${LOKI_WEBHOOK_URL:-}" ]; then
        echo -e "  ${GREEN}[OK]${NC} Webhook   - Configured"
        any_configured=true
    else
        echo -e "  ${DIM}[--]${NC} Webhook   - Not configured (set LOKI_WEBHOOK_URL)"
    fi

    echo ""

    # Check channel filter
    if [ -n "${LOKI_NOTIFY_CHANNELS:-}" ]; then
        echo -e "${CYAN}Active channels:${NC} ${LOKI_NOTIFY_CHANNELS}"
    else
        echo -e "${CYAN}Active channels:${NC} all configured"
    fi

    echo ""

    if [ "$any_configured" = "false" ]; then
        echo -e "${YELLOW}No notification channels configured.${NC}"
        echo "Set environment variables or add to .loki/config.yaml"
    else
        echo -e "Test with: ${CYAN}loki notify test${NC}"
    fi
}

cmd_notify_test() {
    local message="${1:-Loki Mode test notification}"
    local channels_notified=0

    echo -e "${BOLD}Testing Notification Channels${NC}"
    echo ""

    # Determine which channels to test
    local channels="${LOKI_NOTIFY_CHANNELS:-all}"

    # Test Slack
    if [[ "$channels" == "all" || "$channels" == *"slack"* ]]; then
        if [ -n "${LOKI_SLACK_WEBHOOK:-}" ]; then
            echo -n "  Slack...    "
            if send_slack_notification "$message" "Test"; then
                echo -e "${GREEN}OK${NC}"
                ((channels_notified++))
            else
                echo -e "${RED}FAILED${NC}"
            fi
        fi
    fi

    # Test Discord
    if [[ "$channels" == "all" || "$channels" == *"discord"* ]]; then
        if [ -n "${LOKI_DISCORD_WEBHOOK:-}" ]; then
            echo -n "  Discord...  "
            if send_discord_notification "$message" "Test"; then
                echo -e "${GREEN}OK${NC}"
                ((channels_notified++))
            else
                echo -e "${RED}FAILED${NC}"
            fi
        fi
    fi

    # Test custom webhook
    if [[ "$channels" == "all" || "$channels" == *"webhook"* ]]; then
        if [ -n "${LOKI_WEBHOOK_URL:-}" ]; then
            echo -n "  Webhook...  "
            if send_webhook_notification "$message" "Test"; then
                echo -e "${GREEN}OK${NC}"
                ((channels_notified++))
            else
                echo -e "${RED}FAILED${NC}"
            fi
        fi
    fi

    echo ""

    if [ $channels_notified -eq 0 ]; then
        echo -e "${YELLOW}No channels configured or enabled.${NC}"
        echo "Run 'loki notify status' to check configuration."
        exit 1
    else
        echo -e "${GREEN}Sent to $channels_notified channel(s)${NC}"
    fi
}

cmd_notify_send() {
    local channel="$1"
    shift
    local message="$*"

    if [ -z "$message" ]; then
        echo -e "${RED}Error: Message required${NC}"
        echo "Usage: loki notify $channel <message>"
        exit 1
    fi

    case "$channel" in
        slack)
            if [ -z "${LOKI_SLACK_WEBHOOK:-}" ]; then
                echo -e "${RED}Error: LOKI_SLACK_WEBHOOK not set${NC}"
                exit 1
            fi
            if send_slack_notification "$message" "Manual"; then
                echo -e "${GREEN}Sent to Slack${NC}"
            else
                echo -e "${RED}Failed to send to Slack${NC}"
                exit 1
            fi
            ;;
        discord)
            if [ -z "${LOKI_DISCORD_WEBHOOK:-}" ]; then
                echo -e "${RED}Error: LOKI_DISCORD_WEBHOOK not set${NC}"
                exit 1
            fi
            if send_discord_notification "$message" "Manual"; then
                echo -e "${GREEN}Sent to Discord${NC}"
            else
                echo -e "${RED}Failed to send to Discord${NC}"
                exit 1
            fi
            ;;
        webhook)
            if [ -z "${LOKI_WEBHOOK_URL:-}" ]; then
                echo -e "${RED}Error: LOKI_WEBHOOK_URL not set${NC}"
                exit 1
            fi
            if send_webhook_notification "$message" "Manual"; then
                echo -e "${GREEN}Sent to webhook${NC}"
            else
                echo -e "${RED}Failed to send to webhook${NC}"
                exit 1
            fi
            ;;
    esac
}

# Send notification to Slack via incoming webhook
send_slack_notification() {
    local message="$1"
    local event_type="${2:-Notification}"
    local webhook_url="${LOKI_SLACK_WEBHOOK:-}"

    if [ -z "$webhook_url" ]; then
        return 1
    fi

    local project_name
    project_name=$(basename "$(pwd)")
    local timestamp
    timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    local message_escaped event_escaped project_escaped
    message_escaped=$(printf '%s' "$message" | sed 's/\\/\\\\/g; s/"/\\"/g; s/	/\\t/g')
    event_escaped=$(printf '%s' "$event_type" | sed 's/\\/\\\\/g; s/"/\\"/g; s/	/\\t/g')
    project_escaped=$(printf '%s' "$project_name" | sed 's/\\/\\\\/g; s/"/\\"/g; s/	/\\t/g')

    # Build Slack payload with blocks for better formatting
    local payload
    payload=$(cat <<EOF
{
    "blocks": [
        {
            "type": "header",
            "text": {
                "type": "plain_text",
                "text": "Loki Mode: $event_escaped"
            }
        },
        {
            "type": "section",
            "text": {
                "type": "mrkdwn",
                "text": "$message_escaped"
            }
        },
        {
            "type": "context",
            "elements": [
                {
                    "type": "mrkdwn",
                    "text": "*Project:* $project_escaped | *Time:* $timestamp"
                }
            ]
        }
    ]
}
EOF
)

    # Send to Slack
    curl -s -X POST -H 'Content-type: application/json' \
        --data "$payload" \
        "$webhook_url" > /dev/null 2>&1
}

# Send notification to Discord via webhook
send_discord_notification() {
    local message="$1"
    local event_type="${2:-Notification}"
    local webhook_url="${LOKI_DISCORD_WEBHOOK:-}"

    if [ -z "$webhook_url" ]; then
        return 1
    fi

    local project_name
    project_name=$(basename "$(pwd)")
    local timestamp
    timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    local message_escaped event_escaped project_escaped
    message_escaped=$(printf '%s' "$message" | sed 's/\\/\\\\/g; s/"/\\"/g; s/	/\\t/g')
    event_escaped=$(printf '%s' "$event_type" | sed 's/\\/\\\\/g; s/"/\\"/g; s/	/\\t/g')
    project_escaped=$(printf '%s' "$project_name" | sed 's/\\/\\\\/g; s/"/\\"/g; s/	/\\t/g')

    # Build Discord embed payload
    local payload
    payload=$(cat <<EOF
{
    "embeds": [
        {
            "title": "Loki Mode: $event_escaped",
            "description": "$message_escaped",
            "color": 5814783,
            "footer": {
                "text": "Project: $project_escaped | $timestamp"
            }
        }
    ]
}
EOF
)

    # Send to Discord
    curl -s -X POST -H 'Content-type: application/json' \
        --data "$payload" \
        "$webhook_url" > /dev/null 2>&1
}

# Send notification to custom webhook
send_webhook_notification() {
    local message="$1"
    local event_type="${2:-Notification}"
    local webhook_url="${LOKI_WEBHOOK_URL:-}"

    if [ -z "$webhook_url" ]; then
        return 1
    fi

    local project_name
    project_name=$(basename "$(pwd)")
    local timestamp
    timestamp=$(date -u +%Y-%m-%dT%H:%M:%SZ)
    local message_escaped event_escaped project_escaped cwd_escaped
    message_escaped=$(printf '%s' "$message" | sed 's/\\/\\\\/g; s/"/\\"/g; s/	/\\t/g')
    event_escaped=$(printf '%s' "$event_type" | sed 's/\\/\\\\/g; s/"/\\"/g; s/	/\\t/g')
    project_escaped=$(printf '%s' "$project_name" | sed 's/\\/\\\\/g; s/"/\\"/g; s/	/\\t/g')
    cwd_escaped=$(printf '%s' "$(pwd)" | sed 's/\\/\\\\/g; s/"/\\"/g; s/	/\\t/g')

    # Build generic JSON payload
    local payload
    payload=$(cat <<EOF
{
    "source": "loki-mode",
    "event": "$event_escaped",
    "message": "$message_escaped",
    "project": "$project_escaped",
    "timestamp": "$timestamp",
    "cwd": "$cwd_escaped"
}
EOF
)

    # Send to webhook
    curl -s -X POST -H 'Content-type: application/json' \
        --data "$payload" \
        "$webhook_url" > /dev/null 2>&1
}

# Broadcast notification to all configured channels
# Used by run.sh for automated notifications
broadcast_notification() {
    local message="$1"
    local event_type="${2:-Notification}"
    local channels="${LOKI_NOTIFY_CHANNELS:-all}"

    # Send to each enabled channel (silently, for background use)
    if [[ "$channels" == "all" || "$channels" == *"slack"* ]]; then
        send_slack_notification "$message" "$event_type" 2>/dev/null || true
    fi

    if [[ "$channels" == "all" || "$channels" == *"discord"* ]]; then
        send_discord_notification "$message" "$event_type" 2>/dev/null || true
    fi

    if [[ "$channels" == "all" || "$channels" == *"webhook"* ]]; then
        send_webhook_notification "$message" "$event_type" 2>/dev/null || true
    fi
}

# Sandbox management (delegates to sandbox.sh)
# sandbox.sh handles detection: Docker Desktop Sandbox > Docker Container > Worktree
cmd_sandbox() {
    local subcommand="${1:-help}"
    shift || true

    if [ ! -f "$SANDBOX_SH" ]; then
        echo -e "${RED}Error: sandbox.sh not found at $SANDBOX_SH${NC}"
        echo "Expected at: $SKILL_DIR/autonomy/sandbox.sh"
        exit 1
    fi

    # Delegate to sandbox.sh (it handles Docker/worktree detection internally)
    exec "$SANDBOX_SH" "$subcommand" "$@"
}

# Demo mode - simulated session showing multi-agent orchestration
cmd_demo() {
    # Handle --help
    if [[ "${1:-}" == "--help" || "${1:-}" == "-h" ]]; then
        echo -e "${BOLD}loki demo${NC} - Run interactive demo"
        echo ""
        echo "Simulates a full autonomous session in ~60 seconds."
        echo "Starts the dashboard on port 57374 for real-time visualization."
        echo ""
        echo "Usage: loki demo"
        return 0
    fi

    local version=$(get_version)
    local demo_duration=60
    local demo_prd="$SKILL_DIR/templates/simple-todo-app.md"

    # Fall back to examples/ if templates/ doesn't exist yet
    if [ ! -f "$demo_prd" ]; then
        demo_prd="$SKILL_DIR/examples/simple-todo-app.md"
    fi

    if [ ! -f "$demo_prd" ]; then
        echo -e "${RED}Error: Demo PRD not found${NC}"
        echo "Expected at: $demo_prd"
        exit 1
    fi

    echo -e "${BOLD}Loki Mode v$version - Interactive Demo${NC}"
    echo ""
    echo -e "${CYAN}This demo simulates a full autonomous session in ~60 seconds.${NC}"
    echo -e "${CYAN}Watch multi-agent orchestration, quality gates, and phase transitions.${NC}"
    echo ""
    echo -e "PRD: ${BOLD}Simple Todo App${NC}"
    echo -e "Dashboard: ${BLUE}http://127.0.0.1:57374${NC}"
    echo ""

    # Track if we created .loki for cleanup
    local demo_created_loki=false
    if [ ! -d "$LOKI_DIR" ]; then
        demo_created_loki=true
    fi

    # Set up demo .loki directory
    mkdir -p "$LOKI_DIR"/{queue,memory,metrics/efficiency,state,council,logs,dashboard}

    # Write initial session.json
    local demo_pid=$$
    local start_time
    start_time=$(date -u +%Y-%m-%dT%H:%M:%SZ)
    cat > "$LOKI_DIR/session.json" << SESSEOF
{
  "status": "running",
  "pid": $demo_pid,
  "provider": "claude",
  "started": "$start_time",
  "project": "$(pwd)",
  "mode": "demo"
}
SESSEOF
    echo "$demo_pid" > "$LOKI_DIR/loki.pid"

    # Start dashboard server
    local dashboard_started=false
    if command -v python3 &> /dev/null && [ -f "$SKILL_DIR/dashboard/server.py" ]; then
        # Kill any existing dashboard on this port
        local existing_pids
        existing_pids=$(lsof -ti :57374 2>/dev/null || true)
        if [ -n "$existing_pids" ]; then
            echo "$existing_pids" | xargs kill 2>/dev/null || true
            sleep 1
        fi

        LOKI_DIR="$LOKI_DIR" PYTHONPATH="$SKILL_DIR" python3 -m uvicorn dashboard.server:app \
            --host 127.0.0.1 --port 57374 --log-level warning &>/dev/null &
        local dash_pid=$!
        echo "$dash_pid" > "$LOKI_DIR/dashboard/dashboard.pid"

        # Wait for dashboard to be ready
        local wait_count=0
        while [ $wait_count -lt 10 ]; do
            if curl -s http://127.0.0.1:57374/health &>/dev/null; then
                dashboard_started=true
                echo -e "${GREEN}Dashboard started${NC} at http://127.0.0.1:57374"
                break
            fi
            sleep 0.5
            wait_count=$((wait_count + 1))
        done

        if [ "$dashboard_started" = false ]; then
            echo -e "${YELLOW}Warning: Dashboard failed to start, continuing without it${NC}"
        fi
    fi

    echo ""
    echo -e "${DIM}------- Demo Session Starting -------${NC}"
    echo ""

    # Define demo phases and their durations
    local phases=("PLANNING" "ARCHITECTURE" "DEVELOPMENT" "TESTING" "CODE_REVIEW" "QUALITY_ASSURANCE" "DEPLOYMENT_PREP")
    local phase_durations=(6 6 15 10 8 8 7)
    local agents=("planner" "architect" "frontend-dev" "backend-dev" "test-engineer" "reviewer-1" "reviewer-2" "reviewer-3" "qa-engineer" "deploy-engineer")
    local tasks=("Analyze PRD requirements" "Design system architecture" "Scaffold React frontend" "Create Express API server" "Set up SQLite database" "Implement todo CRUD operations" "Write unit tests" "Run code review (3 reviewers)" "Quality gate validation" "Prepare deployment artifacts")

    local iteration=1
    local completed_tasks=0
    local total_tasks=${#tasks[@]}
    local elapsed=0
    local task_idx=0

    # Cleanup handler (guard against double-run)
    local _demo_cleaned=false
    cleanup_demo() {
        if [ "$_demo_cleaned" = true ]; then return; fi
        _demo_cleaned=true
        echo ""
        echo -e "${DIM}------- Demo Session Complete -------${NC}"
        echo ""

        # Summary
        echo -e "${BOLD}Session Summary${NC}"
        echo -e "  Phases completed:  ${#phases[@]}/${#phases[@]}"
        echo -e "  Tasks completed:   $total_tasks/$total_tasks"
        echo -e "  Quality gates:     7/7 passed"
        echo -e "  Agents dispatched: ${#agents[@]}"
        echo -e "  Iterations:        $iteration"
        echo -e "  Duration:          ${elapsed}s"
        echo ""
        echo -e "${GREEN}All quality gates passed. Project ready for deployment.${NC}"
        echo ""
        echo -e "${CYAN}Ready to try it for real?${NC}"
        echo -e "  loki start ./prd.md        Start with your own PRD"
        echo -e "  loki init                  Build a PRD interactively"
        echo -e "  loki quick \"add feature\"   Quick single-task mode"
        echo ""

        # Mark session stopped
        if [ -f "$LOKI_DIR/session.json" ]; then
            LOKI_SESSION_FILE="$LOKI_DIR/session.json" python3 -c "
import json, os
p = os.environ['LOKI_SESSION_FILE']
with open(p, 'r') as f:
    d = json.load(f)
d['status'] = 'stopped'
with open(p, 'w') as f:
    json.dump(d, f, indent=2)
" 2>/dev/null || true
        fi

        # Kill dashboard
        if [ -f "$LOKI_DIR/dashboard/dashboard.pid" ]; then
            local dpid
            dpid=$(cat "$LOKI_DIR/dashboard/dashboard.pid" 2>/dev/null)
            if [ -n "$dpid" ]; then
                kill "$dpid" 2>/dev/null || true
            fi
        fi
        # Also kill by port
        local port_pids
        port_pids=$(lsof -ti :57374 2>/dev/null || true)
        if [ -n "$port_pids" ]; then
            echo "$port_pids" | xargs kill 2>/dev/null || true
        fi

        # Clean up demo artifacts if we created .loki
        if [ "$demo_created_loki" = true ] && [ -d "$LOKI_DIR" ]; then
            rm -rf "$LOKI_DIR"
        fi
    }

    trap cleanup_demo EXIT INT TERM

    # Run through phases
    for phase_idx in "${!phases[@]}"; do
        local phase="${phases[$phase_idx]}"
        local duration="${phase_durations[$phase_idx]}"

        echo -e "${BOLD}[$phase]${NC} Phase $((phase_idx + 1))/${#phases[@]}"

        # Write dashboard state for this phase
        _write_demo_state "$phase" "$iteration" "$completed_tasks" "$total_tasks" "$elapsed"

        # Simulate work within this phase
        local phase_elapsed=0
        while [ $phase_elapsed -lt $duration ]; do
            # Show task progress
            if [ $task_idx -lt $total_tasks ]; then
                local task="${tasks[$task_idx]}"
                local agent="${agents[$((task_idx % ${#agents[@]}))]}"
                echo -e "  ${CYAN}[agent:$agent]${NC} $task"

                # Write task to queue
                echo "{\"id\":\"task-$task_idx\",\"title\":\"$task\",\"status\":\"completed\",\"agent\":\"$agent\"}" \
                    > "$LOKI_DIR/queue/task-$task_idx.json" 2>/dev/null

                completed_tasks=$((completed_tasks + 1))
                task_idx=$((task_idx + 1))
            fi

            # Quality gate checks at specific phases
            if [ "$phase" = "CODE_REVIEW" ]; then
                echo -e "  ${GREEN}[gate]${NC} Blind review: 3/3 reviewers approve"
                sleep 1
                echo -e "  ${GREEN}[gate]${NC} Anti-sycophancy check: devil's advocate triggered"
                sleep 1
            elif [ "$phase" = "QUALITY_ASSURANCE" ]; then
                echo -e "  ${GREEN}[gate]${NC} Static analysis: 0 issues"
                sleep 1
                echo -e "  ${GREEN}[gate]${NC} Test coverage: 87% (threshold: 80%)"
                sleep 1
                echo -e "  ${GREEN}[gate]${NC} Security scan: no vulnerabilities"
                sleep 1
            fi

            iteration=$((iteration + 1))
            local step_sleep=2
            if [ $((duration - phase_elapsed)) -lt 3 ]; then
                step_sleep=1
            fi
            sleep $step_sleep
            phase_elapsed=$((phase_elapsed + step_sleep))
            elapsed=$((elapsed + step_sleep))

            # Update dashboard state
            _write_demo_state "$phase" "$iteration" "$completed_tasks" "$total_tasks" "$elapsed"
        done

        echo ""
    done

    # Final state - completion council
    echo -e "${BOLD}[COMPLETION_COUNCIL]${NC} Evaluating project completion..."
    _write_demo_state "COMPLETION_COUNCIL" "$iteration" "$total_tasks" "$total_tasks" "$elapsed"
    sleep 2
    echo -e "  ${GREEN}[council]${NC} Member 1: COMPLETE (all acceptance criteria met)"
    sleep 1
    echo -e "  ${GREEN}[council]${NC} Member 2: COMPLETE (tests passing, code reviewed)"
    sleep 1
    echo -e "  ${GREEN}[council]${NC} Member 3: COMPLETE (deployment artifacts ready)"
    sleep 1
    echo -e "  ${GREEN}[verdict]${NC} Unanimous: PROJECT COMPLETE (3/3 votes)"

    # Write final state
    _write_demo_state "COMPLETE" "$iteration" "$total_tasks" "$total_tasks" "$elapsed"

    exit 0
}

# Helper: write dashboard-state.json during demo
_write_demo_state() {
    local phase="$1" iteration="$2" completed="$3" total="$4" elapsed="$5"
    local running_agents=$((RANDOM % 3 + 1))
    local pending=$((total - completed))
    local temp_file="$LOKI_DIR/.dashboard-state.json.tmp"

    cat > "$temp_file" << STATEEOF
{
  "status": "running",
  "mode": "demo",
  "phase": "$phase",
  "iteration": $iteration,
  "complexity": "standard",
  "provider": "claude",
  "current_task": "",
  "pending_tasks": $pending,
  "completed_tasks": $completed,
  "failed_tasks": 0,
  "running_agents": $running_agents,
  "total_agents": 10,
  "uptime_seconds": $elapsed,
  "version": "$(get_version)",
  "agents": [],
  "council": {
    "enabled": true,
    "last_verdict": null,
    "convergence_score": 0
  }
}
STATEEOF
    mv "$temp_file" "$LOKI_DIR/dashboard-state.json" 2>/dev/null
}

# Quick mode - lightweight single-task execution
cmd_quick() {
    if [ $# -eq 0 ]; then
        echo -e "${RED}Error: No task description provided${NC}"
        echo ""
        echo "Usage: loki quick \"description of what to do\""
        echo ""
        echo "Examples:"
        echo "  loki quick \"add dark mode to this React app\""
        echo "  loki quick \"fix the login bug in auth.js\""
        echo "  loki quick \"add input validation to the signup form\""
        echo "  loki quick \"write unit tests for the API endpoints\""
        exit 1
    fi

    local task_desc="$*"
    local version=$(get_version)

    echo -e "${BOLD}Loki Mode v$version - Quick Mode${NC}"
    echo ""
    echo -e "${CYAN}Task:${NC} $task_desc"
    echo -e "${DIM}Running lightweight execution (3 iterations max, no quality council)${NC}"
    echo ""

    # Create quick PRD from task description
    mkdir -p "$LOKI_DIR"
    local quick_prd="$LOKI_DIR/quick-prd.md"
    cat > "$quick_prd" << QPRDEOF
# Quick Task

## Overview
$task_desc

## Requirements
- Complete the task described above
- Follow existing code patterns and conventions
- Write tests if applicable
- Do not break existing functionality

## Success Criteria
- Task is completed as described
- No errors or regressions introduced
- Code follows project conventions

## Constraints
- This is a quick single-task execution
- Keep changes minimal and focused
- Do not refactor unrelated code

---

**Mode:** Quick (lightweight, single-task)
QPRDEOF

    echo -e "${GREEN}Quick PRD generated${NC} at $quick_prd"
    echo ""

    # Set lightweight execution environment
    export LOKI_MAX_ITERATIONS=3
    export LOKI_COMPLEXITY=simple
    export LOKI_COUNCIL_ENABLED=false
    export LOKI_PHASE_CODE_REVIEW=false
    export LOKI_PHASE_PERFORMANCE=false
    export LOKI_PHASE_ACCESSIBILITY=false
    export LOKI_PHASE_REGRESSION=false
    export LOKI_PHASE_UAT=false
    export LOKI_PHASE_WEB_RESEARCH=false

    # Record start for efficiency tracking
    record_session_start

    # Emit event
    emit_event session cli quick_start "task=$(echo "$task_desc" | head -c 100)"

    # Run the orchestrator with quick settings
    exec "$RUN_SH" "$quick_prd"
}

# Interactive PRD builder
cmd_init() {
    local version=$(get_version)
    local output_file="./prd.md"
    local template=""
    local start_after=false

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --output|-o)
                if [[ -n "${2:-}" ]]; then
                    output_file="$2"
                    shift 2
                else
                    echo -e "${RED}--output requires a file path${NC}"
                    exit 1
                fi
                ;;
            --template|-t)
                if [[ -n "${2:-}" ]]; then
                    template="$2"
                    shift 2
                else
                    echo -e "${RED}--template requires a template name${NC}"
                    exit 1
                fi
                ;;
            --start|-s)
                start_after=true
                shift
                ;;
            --list-templates)
                _list_templates
                exit 0
                ;;
            --help|-h)
                echo -e "${BOLD}loki init${NC} - Interactive PRD builder"
                echo ""
                echo "Usage: loki init [options]"
                echo ""
                echo "Options:"
                echo "  --output, -o FILE       Output file (default: ./prd.md)"
                echo "  --template, -t NAME     Start from a template"
                echo "  --start, -s             Start loki mode after generating PRD"
                echo "  --list-templates        List available templates"
                echo ""
                echo "Examples:"
                echo "  loki init                         Interactive PRD builder"
                echo "  loki init -t saas-starter         Start from SaaS template"
                echo "  loki init -o docs/requirements.md Custom output path"
                echo "  loki init --start                 Build PRD and start immediately"
                exit 0
                ;;
            *)
                echo -e "${RED}Unknown option: $1${NC}"
                exit 1
                ;;
        esac
    done

    # If template specified, copy it
    if [ -n "$template" ]; then
        local template_file=""
        # Check templates/ directory
        for dir in "$SKILL_DIR/templates" "$SKILL_DIR/examples"; do
            if [ -f "$dir/$template.md" ]; then
                template_file="$dir/$template.md"
                break
            elif [ -f "$dir/${template}" ]; then
                template_file="$dir/${template}"
                break
            fi
        done

        if [ -z "$template_file" ]; then
            echo -e "${RED}Template not found: $template${NC}"
            echo ""
            _list_templates
            exit 1
        fi

        cp "$template_file" "$output_file"
        echo -e "${GREEN}Created${NC} $output_file from template: $template"
        echo -e "${DIM}Edit the file to customize it for your project${NC}"

        if [ "$start_after" = true ]; then
            echo ""
            echo -e "${CYAN}Starting Loki Mode...${NC}"
            exec "$0" start "$output_file"
        fi
        exit 0
    fi

    # Interactive mode
    echo -e "${BOLD}Loki Mode v$version - PRD Builder${NC}"
    echo ""
    echo -e "${CYAN}Answer a few questions to generate your PRD.${NC}"
    echo ""

    # Project name
    echo -e -n "${BOLD}Project name:${NC} "
    read -r project_name
    if [ -z "$project_name" ]; then
        echo -e "${RED}Project name is required${NC}"
        exit 1
    fi

    # Description
    echo -e -n "${BOLD}One-line description:${NC} "
    read -r description

    # Project type
    echo ""
    echo -e "${BOLD}Project type:${NC}"
    echo "  1) Web application (full-stack)"
    echo "  2) REST API (backend only)"
    echo "  3) CLI tool"
    echo "  4) Landing page (static)"
    echo "  5) Mobile app (React Native)"
    echo "  6) Browser extension"
    echo "  7) Other"
    echo -e -n "Choose [1-7]: "
    read -r type_choice

    local project_type=""
    local default_stack=""
    case "$type_choice" in
        1) project_type="Web Application"; default_stack="Next.js + TypeScript + Prisma + PostgreSQL" ;;
        2) project_type="REST API"; default_stack="Node.js + Express + TypeScript + SQLite" ;;
        3) project_type="CLI Tool"; default_stack="Node.js + TypeScript + Commander.js" ;;
        4) project_type="Landing Page"; default_stack="HTML + CSS + JavaScript (no framework)" ;;
        5) project_type="Mobile App"; default_stack="React Native + TypeScript + Expo" ;;
        6) project_type="Browser Extension"; default_stack="Chrome Manifest V3 + TypeScript" ;;
        7) project_type="Custom"; default_stack="" ;;
        *) project_type="Web Application"; default_stack="Next.js + TypeScript + Prisma + PostgreSQL" ;;
    esac

    # Tech stack
    echo ""
    if [ -n "$default_stack" ]; then
        echo -e -n "${BOLD}Tech stack${NC} [${DIM}$default_stack${NC}]: "
        read -r tech_stack
        if [ -z "$tech_stack" ]; then
            tech_stack="$default_stack"
        fi
    else
        echo -e -n "${BOLD}Tech stack:${NC} "
        read -r tech_stack
    fi

    # Features
    echo ""
    echo -e "${BOLD}Key features${NC} (enter one per line, empty line to finish):"
    local features=()
    local feat_num=1
    while true; do
        echo -e -n "  ${feat_num}. "
        read -r feature
        if [ -z "$feature" ]; then
            break
        fi
        features+=("$feature")
        feat_num=$((feat_num + 1))
        if [ $feat_num -gt 10 ]; then
            echo -e "${DIM}  (max 10 features)${NC}"
            break
        fi
    done

    if [ ${#features[@]} -eq 0 ]; then
        echo -e "${RED}At least one feature is required${NC}"
        exit 1
    fi

    # Out of scope
    echo ""
    echo -e "${BOLD}Out of scope${NC} (enter one per line, empty line to finish):"
    local exclusions=()
    local exc_num=1
    while true; do
        echo -e -n "  ${exc_num}. "
        read -r exclusion
        if [ -z "$exclusion" ]; then
            break
        fi
        exclusions+=("$exclusion")
        exc_num=$((exc_num + 1))
        if [ $exc_num -gt 10 ]; then
            break
        fi
    done

    # Generate PRD
    {
        echo "# PRD: $project_name"
        echo ""
        echo "## Overview"
        echo "$description"
        echo ""
        echo "## Project Type"
        echo "$project_type"
        echo ""
        echo "## Target Users"
        echo "Developers and end-users who need $description"
        echo ""
        echo "## Features"
        echo ""
        echo "### MVP Features"
        local i=1
        for feat in "${features[@]}"; do
            echo "$i. **$(echo "$feat" | awk '{print toupper(substr($0,1,1)) substr($0,2)}')** - $feat"
            i=$((i + 1))
        done
        echo ""
        echo "## Tech Stack"
        echo "- $tech_stack"
        echo ""
        echo "## Requirements"
        echo "- All features functional and tested"
        echo "- Clean, well-structured code"
        echo "- Error handling with user feedback"
        echo "- Input validation where applicable"
        echo ""
        echo "## Testing"
        echo "- Unit tests for core functionality"
        echo "- Integration tests for API endpoints (if applicable)"
        echo "- Manual testing checklist"
        echo ""
        echo "## Out of Scope"
        if [ ${#exclusions[@]} -gt 0 ]; then
            for exc in "${exclusions[@]}"; do
                echo "- $exc"
            done
        else
            echo "- Authentication (unless specified in features)"
            echo "- Cloud deployment"
            echo "- Performance optimization"
        fi
        echo ""
        echo "## Success Criteria"
        echo "- All MVP features working"
        echo "- Tests passing"
        echo "- No console errors"
        echo "- Code review passes"
        echo ""
        echo "---"
        echo ""
        echo "**Generated by:** loki init v$(get_version)"
    } > "$output_file"

    echo ""
    echo -e "${GREEN}PRD generated:${NC} $output_file"
    echo ""

    if [ "$start_after" = true ]; then
        echo -e "${CYAN}Starting Loki Mode...${NC}"
        exec "$0" start "$output_file"
    else
        echo "Next steps:"
        echo -e "  1. Review and edit: ${BOLD}$output_file${NC}"
        echo -e "  2. Start Loki Mode: ${BOLD}loki start $output_file${NC}"
    fi
}

# Dogfooding statistics
cmd_dogfood() {
    # Handle --help
    if [[ "${1:-}" == "--help" || "${1:-}" == "-h" ]]; then
        echo -e "${BOLD}loki dogfood${NC} - Show self-development statistics"
        echo ""
        echo "Shows what percentage of loki-mode code was written by loki-mode itself."
        echo ""
        echo "Usage: loki dogfood [--json]"
        echo ""
        echo "Options:"
        echo "  --json    Output in JSON format"
        return 0
    fi

    local stats_script="$SKILL_DIR/scripts/dogfood-stats.sh"
    if [ ! -f "$stats_script" ]; then
        echo -e "${RED}Error: dogfood-stats.sh not found${NC}"
        exit 1
    fi

    local json_flag=""
    if [[ "${1:-}" == "--json" ]]; then
        json_flag="--json"
    fi

    bash "$stats_script" $json_flag
}

# List available templates
_list_templates() {
    echo -e "${BOLD}Available Templates${NC}"
    echo ""
    local found=false
    declare -A seen_names
    for dir in "$SKILL_DIR/templates" "$SKILL_DIR/examples"; do
        if [ -d "$dir" ]; then
            for f in "$dir"/*.md; do
                if [ -f "$f" ] && [ "$(basename "$f")" != "README.md" ]; then
                    local name=$(basename "$f" .md)
                    # Skip duplicates (templates/ takes priority over examples/)
                    if [[ -n "${seen_names[$name]:-}" ]]; then
                        continue
                    fi
                    seen_names[$name]=1
                    local title=$(head -1 "$f" | sed -E 's/^#+ *//')
                    echo -e "  ${CYAN}$name${NC} - $title"
                    found=true
                fi
            done
        fi
    done
    if [ "$found" = false ]; then
        echo "  No templates found"
    fi
    echo ""
    echo "Usage: loki init --template <name>"
}

# Watchdog: process health monitoring
cmd_watchdog() {
    local subcommand="${1:-status}"
    shift 2>/dev/null || true

    case "$subcommand" in
        status)
            # Show watchdog state
            if [[ "${LOKI_WATCHDOG:-false}" == "true" ]]; then
                echo -e "${GREEN}Watchdog: ENABLED${NC} (interval: ${LOKI_WATCHDOG_INTERVAL:-30}s)"
            else
                echo "Watchdog: DISABLED"
                echo "Enable with: LOKI_WATCHDOG=true loki start"
            fi

            echo ""
            echo -e "${BOLD}Process Health:${NC}"

            # Check dashboard
            local dpid_file="$LOKI_DIR/dashboard/dashboard.pid"
            if [[ -f "$dpid_file" ]]; then
                local dpid
                dpid=$(cat "$dpid_file" 2>/dev/null)
                if [[ -n "$dpid" ]] && kill -0 "$dpid" 2>/dev/null; then
                    echo -e "  Dashboard (PID $dpid): ${GREEN}alive${NC}"
                else
                    echo -e "  Dashboard (PID ${dpid:-?}): ${RED}DEAD${NC}"
                fi
            else
                echo -e "  Dashboard: ${DIM}not running${NC}"
            fi

            # Check session
            local spid_file="$LOKI_DIR/loki.pid"
            if [[ -f "$spid_file" ]]; then
                local spid
                spid=$(cat "$spid_file" 2>/dev/null)
                if [[ -n "$spid" ]] && kill -0 "$spid" 2>/dev/null; then
                    echo -e "  Session  (PID $spid): ${GREEN}alive${NC}"
                else
                    echo -e "  Session  (PID ${spid:-?}): ${RED}DEAD${NC}"
                fi
            else
                echo -e "  Session:  ${DIM}not running${NC}"
            fi

            # Check agents
            local agents_file="$LOKI_DIR/state/agents.json"
            if [[ -f "$agents_file" ]]; then
                local agent_info
                agent_info=$(python3 -c "
import json, os
try:
    agents = json.load(open('$agents_file'))
    alive = dead = other = 0
    for a in agents:
        pid = a.get('pid')
        status = a.get('status', '')
        if status in ('terminated', 'completed', 'failed', 'crashed'):
            other += 1
            continue
        if pid:
            try:
                os.kill(int(pid), 0)
                alive += 1
            except (OSError, ValueError):
                dead += 1
        else:
            other += 1
    print(f'{alive}:{dead}:{other}')
except Exception:
    print('0:0:0')
" 2>/dev/null || echo "0:0:0")
                local a_alive a_dead a_other
                IFS=: read -r a_alive a_dead a_other <<< "$agent_info"
                if [[ "$a_alive" -gt 0 ]] || [[ "$a_dead" -gt 0 ]]; then
                    echo -e "  Agents:   ${GREEN}${a_alive} alive${NC}, ${RED}${a_dead} dead${NC}, ${DIM}${a_other} finished${NC}"
                elif [[ "$a_other" -gt 0 ]]; then
                    echo -e "  Agents:   ${DIM}${a_other} finished${NC}"
                else
                    echo -e "  Agents:   ${DIM}none${NC}"
                fi
            else
                echo -e "  Agents:   ${DIM}none${NC}"
            fi
            ;;
        help)
            echo "Usage: loki watchdog [status|help]"
            echo ""
            echo "Monitor process health for Loki Mode sessions."
            echo ""
            echo "Subcommands:"
            echo "  status    Show health of dashboard, session, and agent processes (default)"
            echo "  help      Show this help"
            echo ""
            echo "Environment:"
            echo "  LOKI_WATCHDOG=true          Enable watchdog monitoring during sessions"
            echo "  LOKI_WATCHDOG_INTERVAL=30   Check interval in seconds (default: 30)"
            ;;
        *)
            echo -e "${RED}Unknown watchdog command: $subcommand${NC}"
            cmd_watchdog help
            return 1
            ;;
    esac
}

# Main command dispatcher
main() {
    if [ $# -eq 0 ]; then
        show_help
        exit 0
    fi

    local command="$1"
    shift

    loki_telemetry "cli_command" "command=$command" 2>/dev/null || true

    case "$command" in
        start)
            cmd_start "$@"
            ;;
        quick)
            cmd_quick "$@"
            ;;
        demo)
            cmd_demo "$@"
            ;;
        init)
            cmd_init "$@"
            ;;
        stop)
            cmd_stop
            ;;
        pause)
            cmd_pause
            ;;
        resume)
            cmd_resume
            ;;
        status)
            cmd_status "$@"
            ;;
        dashboard)
            cmd_dashboard "$@"
            ;;
        logs)
            cmd_logs "$@"
            ;;
        serve)
            cmd_api start "$@"
            ;;
        api)
            cmd_api "$@"
            ;;
        sandbox)
            cmd_sandbox "$@"
            ;;
        notify)
            cmd_notify "$@"
            ;;
        import)
            cmd_import
            ;;
        github)
            cmd_github "$@"
            ;;
        issue)
            cmd_issue "$@"
            ;;
        config)
            cmd_config "$@"
            ;;
        provider)
            cmd_provider "$@"
            ;;
        reset)
            cmd_reset "$@"
            ;;
        memory)
            cmd_memory "$@"
            ;;
        compound)
            cmd_compound "$@"
            ;;
        checkpoint|cp)
            cmd_checkpoint "$@"
            ;;
        council)
            cmd_council "$@"
            ;;
        dogfood)
            cmd_dogfood "$@"
            ;;
        projects)
            cmd_projects "$@"
            ;;
        enterprise)
            cmd_enterprise "$@"
            ;;
        voice)
            cmd_voice "$@"
            ;;
        secrets)
            cmd_secrets "$@"
            ;;
        doctor)
            cmd_doctor "$@"
            ;;
        watchdog)
            cmd_watchdog "$@"
            ;;
        audit)
            cmd_audit "$@"
            ;;
        metrics)
            cmd_metrics "$@"
            ;;
        version|--version|-v)
            cmd_version
            ;;
	completions)
            cmd_completions "$@"
            ;;
        help|--help|-h)
            show_help
            ;;
        *)
            echo -e "${RED}Unknown command: $command${NC}"
            echo "Run 'loki help' for usage."
            exit 1
            ;;
    esac
}

# Agent action audit log
cmd_audit() {
    local subcommand="${1:-help}"
    local audit_file="$LOKI_DIR/logs/agent-audit.jsonl"

    case "$subcommand" in
        log)
            if [ ! -f "$audit_file" ]; then
                echo -e "${YELLOW}No audit log found at $audit_file${NC}"
                echo "Agent action auditing records entries during loki sessions."
                exit 0
            fi
            local lines="${2:-50}"
            echo -e "${BOLD}Agent Audit Log${NC} (last $lines entries)"
            echo "---"
            tail -n "$lines" "$audit_file" | while IFS= read -r line; do
                if command -v python3 &>/dev/null; then
                    python3 -c "
import json, sys
try:
    e = json.loads(sys.argv[1])
    ts = e.get('timestamp', '?')
    act = e.get('action', '?')
    desc = e.get('description', '')
    it = e.get('iteration', 0)
    print(f'  [{ts}] [{act}] iter={it} {desc}')
except: print(f'  {sys.argv[1]}')
" "$line" 2>/dev/null || echo "  $line"
                else
                    echo "  $line"
                fi
            done
            ;;
        count)
            if [ ! -f "$audit_file" ]; then
                echo -e "${YELLOW}No audit log found${NC}"
                exit 0
            fi
            echo -e "${BOLD}Agent Action Counts${NC}"
            echo "---"
            if command -v python3 &>/dev/null; then
                python3 -c "
import json, sys
from collections import Counter
counts = Counter()
for line in open(sys.argv[1]):
    try:
        e = json.loads(line)
        counts[e.get('action', 'unknown')] += 1
    except: pass
for action, count in sorted(counts.items(), key=lambda x: -x[1]):
    print(f'  {action:25s} {count}')
print(f'  {\"---\":25s} ---')
print(f'  {\"TOTAL\":25s} {sum(counts.values())}')
" "$audit_file" 2>/dev/null
            else
                echo "  python3 required for count summary"
            fi
            ;;
        --help|-h|help)
            echo -e "${BOLD}loki audit${NC} - Agent action audit log"
            echo ""
            echo "Usage: loki audit <subcommand>"
            echo ""
            echo "Subcommands:"
            echo "  log [N]     Show last N audit log entries (default: 50)"
            echo "  count       Count actions by type"
            echo "  help        Show this help"
            echo ""
            echo "The agent audit log records actions taken during Loki sessions,"
            echo "including CLI invocations, git commits, and session lifecycle events."
            echo "Log file: $audit_file"
            ;;
        *)
            echo -e "${RED}Unknown audit subcommand: $subcommand${NC}"
            echo "Run 'loki audit help' for usage."
            exit 1
            ;;
    esac
}

# Reset session state
cmd_reset() {
    require_jq

    local subcommand="${1:-all}"

    case "$subcommand" in
        retries|retry)
            if [ -f "$LOKI_DIR/autonomy-state.json" ]; then
                # Reset only retry count
                if command -v python3 &> /dev/null; then
                    python3 -c "
import json, sys, os
p = os.path.join(sys.argv[1], 'autonomy-state.json')
with open(p, 'r') as f:
    state = json.load(f)
state['retryCount'] = 0
state['status'] = 'reset'
with open(p, 'w') as f:
    json.dump(state, f, indent=4)
" "$LOKI_DIR" 2>/dev/null
                    echo -e "${GREEN}Retry count reset to 0${NC}"
                else
                    rm -f "$LOKI_DIR/autonomy-state.json"
                    echo -e "${GREEN}Autonomy state cleared${NC}"
                fi
            else
                echo -e "${YELLOW}No autonomy state found${NC}"
            fi
            ;;
        failed|failures)
            if [ -f "$LOKI_DIR/queue/failed.json" ]; then
                local count
                count=$(jq 'length' "$LOKI_DIR/queue/failed.json" 2>/dev/null || echo "?")
                rm -f "$LOKI_DIR/queue/failed.json"
                echo "[]" > "$LOKI_DIR/queue/failed.json"
                echo -e "${GREEN}Cleared $count failed tasks${NC}"
            else
                echo -e "${YELLOW}No failed tasks found${NC}"
            fi
            ;;
        all)
            # Reset everything
            rm -f "$LOKI_DIR/autonomy-state.json"
            echo "[]" > "$LOKI_DIR/queue/failed.json" 2>/dev/null
            echo -e "${GREEN}Session state reset${NC}"
            echo "  - Autonomy state cleared"
            echo "  - Failed task queue cleared"
            ;;
        --help|-h|help)
            echo -e "${BOLD}loki reset${NC} - Reset session state"
            echo ""
            echo "Usage: loki reset [target]"
            echo ""
            echo "Targets:"
            echo "  all       Reset everything (default)"
            echo "  retries   Reset only the retry counter"
            echo "  failed    Clear failed task queue"
            echo ""
            echo "Examples:"
            echo "  loki reset              # Reset all state"
            echo "  loki reset retries      # Just reset retry count"
            echo "  loki reset failed       # Clear failed tasks"
            ;;
        *)
            echo -e "${RED}Unknown reset target: $subcommand${NC}"
            echo "Valid targets: all, retries, failed"
            exit 1
            ;;
    esac
}

# Cross-project memory/learnings management
cmd_memory() {
    local subcommand="${1:-list}"
    local learnings_dir="${HOME}/.loki/learnings"

    # Ensure directory exists
    mkdir -p "$learnings_dir"

    case "$subcommand" in
        list|ls)
            echo -e "${BOLD}Cross-Project Learnings${NC}"
            echo ""

            local patterns=0 mistakes=0 successes=0
            [ -f "$learnings_dir/patterns.jsonl" ] && patterns=$(grep -c '"description"' "$learnings_dir/patterns.jsonl" 2>/dev/null) || patterns=0
            [ -f "$learnings_dir/mistakes.jsonl" ] && mistakes=$(grep -c '"description"' "$learnings_dir/mistakes.jsonl" 2>/dev/null) || mistakes=0
            [ -f "$learnings_dir/successes.jsonl" ] && successes=$(grep -c '"description"' "$learnings_dir/successes.jsonl" 2>/dev/null) || successes=0

            echo -e "  Patterns:  ${GREEN}$patterns${NC}"
            echo -e "  Mistakes:  ${YELLOW}$mistakes${NC}"
            echo -e "  Successes: ${CYAN}$successes${NC}"
            echo ""
            echo "Location: $learnings_dir"
            echo ""
            echo "Use 'loki memory show <type>' to view entries"
            ;;

        show)
            # Parse arguments: show <type> [--limit N] [--project P]
            local type="${2:-all}"
            local limit=20
            local project=""
            shift 2 2>/dev/null || true

            while [[ $# -gt 0 ]]; do
                case "$1" in
                    --limit|-l)
                        limit="${2:-20}"
                        if [ $# -ge 2 ]; then shift 2; else shift; fi
                        ;;
                    --project|-p)
                        project="${2:-}"
                        if [ $# -ge 2 ]; then shift 2; else shift; fi
                        ;;
                    *)
                        shift
                        ;;
                esac
            done

            case "$type" in
                patterns|pattern)
                    echo -e "${BOLD}Patterns${NC}"
                    echo ""
                    if [ -f "$learnings_dir/patterns.jsonl" ]; then
                        python3 -c "
import json, sys, os
limit = int(sys.argv[1])
project_filter = sys.argv[2]
filepath = os.path.join(sys.argv[3], 'patterns.jsonl')
count = 0
with open(filepath, 'r') as f:
    for line in f:
        if count >= limit:
            break
        try:
            e = json.loads(line)
            if 'description' in e:
                if project_filter and e.get('project', '') != project_filter:
                    continue
                print(f\"[{e.get('project', 'unknown')}] {e['description'][:100]}\")
                count += 1
        except: pass
if count == 0:
    print('(empty - no patterns recorded)')
" "$limit" "$project" "$learnings_dir" 2>/dev/null
                    else
                        echo "(empty - no patterns recorded)"
                    fi
                    ;;

                mistakes|mistake)
                    echo -e "${BOLD}Mistakes${NC}"
                    echo ""
                    if [ -f "$learnings_dir/mistakes.jsonl" ]; then
                        python3 -c "
import json, sys, os
limit = int(sys.argv[1])
project_filter = sys.argv[2]
filepath = os.path.join(sys.argv[3], 'mistakes.jsonl')
count = 0
with open(filepath, 'r') as f:
    for line in f:
        if count >= limit:
            break
        try:
            e = json.loads(line)
            if 'description' in e:
                if project_filter and e.get('project', '') != project_filter:
                    continue
                print(f\"[{e.get('project', 'unknown')}] {e['description'][:100]}\")
                count += 1
        except: pass
if count == 0:
    print('(empty - no mistakes recorded)')
" "$limit" "$project" "$learnings_dir" 2>/dev/null
                    else
                        echo "(empty - no mistakes recorded)"
                    fi
                    ;;

                successes|success)
                    echo -e "${BOLD}Successes${NC}"
                    echo ""
                    if [ -f "$learnings_dir/successes.jsonl" ]; then
                        python3 -c "
import json, sys, os
limit = int(sys.argv[1])
project_filter = sys.argv[2]
filepath = os.path.join(sys.argv[3], 'successes.jsonl')
count = 0
with open(filepath, 'r') as f:
    for line in f:
        if count >= limit:
            break
        try:
            e = json.loads(line)
            if 'description' in e:
                if project_filter and e.get('project', '') != project_filter:
                    continue
                print(f\"[{e.get('project', 'unknown')}] {e['description'][:100]}\")
                count += 1
        except: pass
if count == 0:
    print('(empty - no successes recorded)')
" "$limit" "$project" "$learnings_dir" 2>/dev/null
                    else
                        echo "(empty - no successes recorded)"
                    fi
                    ;;

                all)
                    cmd_memory show patterns --limit "$limit" --project "$project"
                    echo ""
                    cmd_memory show mistakes --limit "$limit" --project "$project"
                    echo ""
                    cmd_memory show successes --limit "$limit" --project "$project"
                    ;;

                *)
                    echo -e "${RED}Unknown type: $type${NC}"
                    echo "Valid types: patterns, mistakes, successes, all"
                    exit 1
                    ;;
            esac
            ;;

        search)
            local query="${2:-}"
            if [ -z "$query" ]; then
                echo -e "${RED}Usage: loki memory search <query>${NC}"
                exit 1
            fi

            echo -e "${BOLD}Search Results for: $query${NC}"
            echo ""

            LOKI_SEARCH_QUERY="$query" LOKI_LEARNINGS_DIR="$learnings_dir" python3 -c "
import json, os

learnings_dir = os.environ['LOKI_LEARNINGS_DIR']
query = os.environ['LOKI_SEARCH_QUERY'].lower()

for filename in ['patterns.jsonl', 'mistakes.jsonl', 'successes.jsonl']:
    filepath = os.path.join(learnings_dir, filename)
    if not os.path.exists(filepath):
        continue

    category = filename.replace('.jsonl', '')
    with open(filepath, 'r') as f:
        for line in f:
            try:
                e = json.loads(line)
                desc = e.get('description', '').lower()
                if query in desc:
                    print(f\"[{category}] [{e.get('project', 'unknown')}] {e['description'][:80]}...\")
            except: pass
" 2>/dev/null
            ;;

        clear)
            local type="${2:-}"
            local confirm=""

            if [ -z "$type" ]; then
                # LOKI_AUTO_CONFIRM takes precedence when explicitly set;
                # fall back to CI env var only when LOKI_AUTO_CONFIRM is unset
                local _auto_confirm="${LOKI_AUTO_CONFIRM:-${CI:-false}}"
                if [[ "$_auto_confirm" == "true" ]]; then
                    confirm="yes"
                else
                    echo -e "${YELLOW}This will delete ALL cross-project learnings.${NC}"
                    echo -n "Are you sure? (yes/no): "
                    read -r confirm
                fi
                if [ "$confirm" = "yes" ]; then
                    rm -rf "$learnings_dir"
                    mkdir -p "$learnings_dir"
                    echo '{"version":"1.0","created":"'"$(date -u +%Y-%m-%dT%H:%M:%SZ)"'"}' > "$learnings_dir/patterns.jsonl"
                    echo '{"version":"1.0","created":"'"$(date -u +%Y-%m-%dT%H:%M:%SZ)"'"}' > "$learnings_dir/mistakes.jsonl"
                    echo '{"version":"1.0","created":"'"$(date -u +%Y-%m-%dT%H:%M:%SZ)"'"}' > "$learnings_dir/successes.jsonl"
                    echo -e "${GREEN}All learnings cleared${NC}"
                else
                    echo "Cancelled"
                fi
            else
                case "$type" in
                    patterns|mistakes|successes)
                        echo '{"version":"1.0","created":"'"$(date -u +%Y-%m-%dT%H:%M:%SZ)"'"}' > "$learnings_dir/${type}.jsonl"
                        echo -e "${GREEN}Cleared $type${NC}"
                        ;;
                    *)
                        echo -e "${RED}Unknown type: $type${NC}"
                        echo "Valid types: patterns, mistakes, successes"
                        exit 1
                        ;;
                esac
            fi
            ;;

        export)
            local output="${2:-learnings-export.json}"

            LOKI_LEARNINGS_DIR="$learnings_dir" python3 -c "
import json
import os

learnings_dir = os.environ['LOKI_LEARNINGS_DIR']
result = {'patterns': [], 'mistakes': [], 'successes': []}

for category in ['patterns', 'mistakes', 'successes']:
    filepath = os.path.join(learnings_dir, f'{category}.jsonl')
    if os.path.exists(filepath):
        with open(filepath, 'r') as f:
            for line in f:
                try:
                    e = json.loads(line)
                    if 'description' in e:
                        result[category].append(e)
                except: pass

with open('$output', 'w') as f:
    json.dump(result, f, indent=2)
print(f'Exported to $output')
" 2>/dev/null
            ;;

        stats)
            echo -e "${BOLD}Learning Statistics${NC}"
            echo ""

            LOKI_LEARNINGS_DIR="$learnings_dir" python3 -c "
import json
import os
from collections import Counter

learnings_dir = os.environ['LOKI_LEARNINGS_DIR']
projects = Counter()
categories = Counter()

for filename in ['patterns.jsonl', 'mistakes.jsonl', 'successes.jsonl']:
    filepath = os.path.join(learnings_dir, filename)
    if not os.path.exists(filepath):
        continue

    category = filename.replace('.jsonl', '')
    with open(filepath, 'r') as f:
        for line in f:
            try:
                e = json.loads(line)
                if 'description' in e:
                    projects[e.get('project', 'unknown')] += 1
                    categories[category] += 1
            except: pass

print('By Category:')
for cat, count in categories.most_common():
    print(f'  {cat}: {count}')

print()
print('By Project:')
for proj, count in projects.most_common(10):
    print(f'  {proj}: {count}')
" 2>/dev/null
            ;;

        dedupe|dedup)
            echo -e "${BOLD}Deduplicating Learnings${NC}"
            echo ""

            LOKI_LEARNINGS_DIR="$learnings_dir" python3 -c "
import json
import os
import hashlib
from datetime import datetime, timezone

learnings_dir = os.environ['LOKI_LEARNINGS_DIR']

def dedupe_file(filepath):
    '''Deduplicate a JSONL file, keeping first occurrence of each unique description'''
    if not os.path.exists(filepath):
        return 0, 0

    seen_hashes = set()
    unique_entries = []
    duplicates = 0

    # Read all entries
    with open(filepath, 'r') as f:
        for line in f:
            try:
                entry = json.loads(line)
                if 'description' not in entry:
                    # Keep header/metadata lines
                    if 'version' in entry:
                        unique_entries.append(entry)
                    continue

                # Normalize description for hashing (case-insensitive, trimmed)
                desc = entry['description'].strip().lower()
                h = hashlib.md5(desc.encode()).hexdigest()

                if h not in seen_hashes:
                    seen_hashes.add(h)
                    unique_entries.append(entry)
                else:
                    duplicates += 1
            except json.JSONDecodeError:
                continue

    # Write back unique entries
    with open(filepath, 'w') as f:
        for entry in unique_entries:
            f.write(json.dumps(entry) + '\n')

    return len(unique_entries) - (1 if unique_entries and 'version' in unique_entries[0] else 0), duplicates

total_kept = 0
total_removed = 0

for category in ['patterns', 'mistakes', 'successes']:
    filepath = os.path.join(learnings_dir, f'{category}.jsonl')
    kept, removed = dedupe_file(filepath)
    total_kept += kept
    total_removed += removed
    if removed > 0:
        print(f'{category}: kept {kept}, removed {removed} duplicates')
    else:
        print(f'{category}: {kept} entries (no duplicates)')

print()
print(f'Total: kept {total_kept} unique entries, removed {total_removed} duplicates')
if total_removed > 0:
    reduction = total_removed / (total_kept + total_removed) * 100
    print(f'Storage reduced by {reduction:.1f}%')
" 2>/dev/null
            ;;

        index)
            # Show or rebuild the memory index layer
            if [ "${2:-}" = "rebuild" ]; then
                python3 -c "
try:
    from memory.layers import IndexLayer
    layer = IndexLayer('.loki/memory')
    layer.update([])  # Will scan and rebuild
    print('Index rebuilt')
except ImportError:
    print('Error: memory.layers module not found')
except Exception as e:
    print(f'Error: {e}')
" 2>/dev/null
            else
                cat .loki/memory/index.json 2>/dev/null | python3 -m json.tool 2>/dev/null || echo "No index found"
            fi
            ;;

        timeline)
            # Show timeline layer
            cat .loki/memory/timeline.json 2>/dev/null | python3 -m json.tool 2>/dev/null || echo "No timeline found"
            ;;

        consolidate)
            # Run consolidation pipeline
            local hours="${2:-24}"
            LOKI_HOURS="$hours" python3 -c "
import os
try:
    from memory.consolidation import ConsolidationPipeline
    from memory.storage import MemoryStorage
    storage = MemoryStorage('.loki/memory')
    pipeline = ConsolidationPipeline(storage)
    result = pipeline.consolidate(since_hours=int(os.environ.get('LOKI_HOURS', '24')))
    print('Consolidation complete:')
    print(f'  Patterns created: {result.patterns_created}')
    print(f'  Patterns merged: {result.patterns_merged}')
    print(f'  Anti-patterns: {result.anti_patterns_created}')
    print(f'  Links created: {result.links_created}')
    print(f'  Episodes processed: {result.episodes_processed}')
except ImportError as e:
    print(f'Error: Required module not found - {e}')
except Exception as e:
    print(f'Error: {e}')
" 2>/dev/null
            ;;

        economics)
            # Show token economics
            if [ -f ".loki/memory/token_economics.json" ]; then
                cat .loki/memory/token_economics.json | python3 -m json.tool 2>/dev/null || echo "Error parsing token economics JSON"
            else
                echo "No token economics data. Run a session first."
            fi
            ;;

        retrieve)
            # Test memory retrieval
            local query="${2:-}"
            if [ -z "$query" ]; then
                echo "Usage: loki memory retrieve <query>"
                exit 1
            fi
            LOKI_QUERY="$query" python3 -c "
import os
try:
    from memory.retrieval import MemoryRetrieval
    from memory.storage import MemoryStorage
    query = os.environ.get('LOKI_QUERY', '')
    storage = MemoryStorage('.loki/memory')
    retriever = MemoryRetrieval(storage)
    results = retriever.retrieve_task_aware({'goal': query}, top_k=5)
    if not results:
        print('No relevant memories found')
    else:
        for i, r in enumerate(results, 1):
            source = r.get('source', 'unknown')
            summary = r.get('summary', r.get('pattern', 'No summary'))[:80]
            score = r.get('score', 0)
            print(f'{i}. [{source}] {summary}... (score: {score:.2f})')
except ImportError as e:
    print(f'Error: Required module not found - {e}')
except Exception as e:
    print(f'Error: {e}')
" 2>/dev/null
            ;;

        episode)
            # Show full episode by ID
            local id="${2:-}"
            if [ -z "$id" ]; then
                echo "Usage: loki memory episode <id>"
                exit 1
            fi
            LOKI_ID="$id" python3 -c "
import os
try:
    from memory.engine import MemoryEngine
    import json
    episode_id = os.environ.get('LOKI_ID', '')
    engine = MemoryEngine(base_path='.loki/memory')
    episode = engine.get_episode(episode_id)
    if episode:
        print(json.dumps(episode.to_dict(), indent=2))
    else:
        print(f'Episode not found: {episode_id}')
except ImportError as e:
    print(f'Error: Required module not found - {e}')
except Exception as e:
    print(f'Error: {e}')
" 2>/dev/null
            ;;

        pattern)
            # Show semantic pattern by ID or list all patterns
            local id="${2:-}"
            if [ -z "$id" ]; then
                # List all patterns
                python3 -c "
try:
    from memory.engine import MemoryEngine
    engine = MemoryEngine(base_path='.loki/memory')
    patterns = engine.find_patterns()
    if not patterns:
        print('No patterns found')
    else:
        for p in patterns[:20]:
            pattern_text = p.pattern[:60] if hasattr(p, 'pattern') else str(p)[:60]
            confidence = p.confidence if hasattr(p, 'confidence') else 0.0
            print(f'{p.id}: {pattern_text}... (conf: {confidence:.2f})')
except ImportError as e:
    print(f'Error: Required module not found - {e}')
except Exception as e:
    print(f'Error: {e}')
" 2>/dev/null
            else
                LOKI_ID="$id" python3 -c "
import os
try:
    from memory.engine import MemoryEngine
    import json
    pattern_id = os.environ.get('LOKI_ID', '')
    engine = MemoryEngine(base_path='.loki/memory')
    pattern = engine.get_pattern(pattern_id)
    if pattern:
        print(json.dumps(pattern.to_dict(), indent=2))
    else:
        print(f'Pattern not found: {pattern_id}')
except ImportError as e:
    print(f'Error: Required module not found - {e}')
except Exception as e:
    print(f'Error: {e}')
" 2>/dev/null
            fi
            ;;

        skill)
            # Show procedural skill by name or list all skills
            local name="${2:-}"
            if [ -z "$name" ]; then
                # List all skills
                if ls -1 .loki/memory/skills/*.json 2>/dev/null | head -1 >/dev/null 2>&1; then
                    ls -1 .loki/memory/skills/*.json 2>/dev/null | xargs -I{} basename {} .json
                else
                    echo "No skills found"
                fi
            else
                if [ -f ".loki/memory/skills/${name}.json" ]; then
                    cat ".loki/memory/skills/${name}.json" | python3 -m json.tool 2>/dev/null || echo "Error parsing skill JSON"
                else
                    echo "Skill not found: $name"
                fi
            fi
            ;;

        vectors)
            # Manage vector indices
            if [ "${2:-}" = "rebuild" ]; then
                python3 -c "
try:
    from memory.retrieval import MemoryRetrieval
    from memory.storage import MemoryStorage
    storage = MemoryStorage('.loki/memory')
    retriever = MemoryRetrieval(storage)
    retriever.build_indices()
    retriever.save_indices()
    print('Vector indices rebuilt')
except ImportError as e:
    print(f'Error: Required module not found - {e}')
except Exception as e:
    print(f'Error: {e}')
" 2>/dev/null
            else
                echo "Vector index stats:"
                if ls -1 .loki/memory/vectors/*.npz 2>/dev/null | head -1 >/dev/null 2>&1; then
                    for f in .loki/memory/vectors/*.npz; do
                        if [ -f "$f" ]; then
                            count=$(python3 -c "import numpy as np; d=np.load('$f'); print(len(d['ids']))" 2>/dev/null || echo "error")
                            echo "  $(basename "$f"): $count vectors"
                        fi
                    done
                else
                    echo "  No vector indices found"
                fi
            fi
            ;;

        namespace|ns)
            # Namespace management (COMP-005)
            local ns_cmd="${2:-detect}"
            shift 2 2>/dev/null || true

            case "$ns_cmd" in
                detect)
                    # Auto-detect namespace from current directory
                    python3 -c "
try:
    from memory.namespace import detect_namespace
    ns = detect_namespace()
    print(f'Detected namespace: {ns}')
except ImportError as e:
    print(f'Error: memory.namespace module not found - {e}')
except Exception as e:
    print(f'Error: {e}')
" 2>/dev/null
                    ;;

                list|ls)
                    # List all namespaces
                    python3 -c "
try:
    from memory.storage import MemoryStorage
    storage = MemoryStorage('.loki/memory')
    namespaces = storage.list_namespaces()
    if not namespaces:
        print('No namespaces found')
    else:
        print('Available namespaces:')
        for ns in namespaces:
            stats = storage.get_namespace_stats(ns)
            print(f'  {ns}: {stats[\"episode_count\"]} episodes, {stats[\"pattern_count\"]} patterns, {stats[\"skill_count\"]} skills')
except ImportError as e:
    print(f'Error: memory.storage module not found - {e}')
except Exception as e:
    print(f'Error: {e}')
" 2>/dev/null
                    ;;

                create)
                    # Create a new namespace
                    local name="${1:-}"
                    local parent="${2:-}"

                    if [ -z "$name" ]; then
                        echo "Usage: loki memory namespace create <name> [parent]"
                        exit 1
                    fi

                    LOKI_NS_NAME="$name" LOKI_NS_PARENT="$parent" python3 -c "
import os
try:
    from memory.namespace import NamespaceManager
    name = os.environ.get('LOKI_NS_NAME', '')
    parent = os.environ.get('LOKI_NS_PARENT', '') or None

    manager = NamespaceManager('.loki/memory')
    info = manager.create_namespace(name=name, parent=parent)
    print(f'Created namespace: {info.name}')
    print(f'  Path: {info.path}')
    if info.parent:
        print(f'  Parent: {info.parent}')
except ValueError as e:
    print(f'Error: {e}')
except ImportError as e:
    print(f'Error: memory.namespace module not found - {e}')
except Exception as e:
    print(f'Error: {e}')
" 2>/dev/null
                    ;;

                delete|rm)
                    # Delete a namespace
                    local name="${1:-}"
                    local delete_data="${2:-}"

                    if [ -z "$name" ]; then
                        echo "Usage: loki memory namespace delete <name> [--data]"
                        exit 1
                    fi

                    local with_data="false"
                    if [ "$delete_data" = "--data" ]; then
                        with_data="true"
                    fi

                    LOKI_NS_NAME="$name" LOKI_DELETE_DATA="$with_data" python3 -c "
import os
try:
    from memory.namespace import NamespaceManager
    name = os.environ.get('LOKI_NS_NAME', '')
    delete_data = os.environ.get('LOKI_DELETE_DATA', 'false') == 'true'

    manager = NamespaceManager('.loki/memory')
    result = manager.delete_namespace(name, delete_data=delete_data)
    if result:
        msg = f'Deleted namespace: {name}'
        if delete_data:
            msg += ' (including data)'
        print(msg)
    else:
        print(f'Namespace not found: {name}')
except ValueError as e:
    print(f'Error: {e}')
except ImportError as e:
    print(f'Error: memory.namespace module not found - {e}')
except Exception as e:
    print(f'Error: {e}')
" 2>/dev/null
                    ;;

                stats)
                    # Show stats for a namespace
                    local name="${1:-}"

                    if [ -z "$name" ]; then
                        # Show current namespace stats
                        python3 -c "
try:
    from memory.namespace import detect_namespace
    from memory.storage import MemoryStorage
    ns = detect_namespace()
    storage = MemoryStorage('.loki/memory', namespace=ns)
    stats = storage.get_namespace_stats()
    print(f'Namespace: {stats[\"namespace\"]}')
    print(f'  Path: {stats[\"path\"]}')
    print(f'  Episodes: {stats[\"episode_count\"]}')
    print(f'  Patterns: {stats[\"pattern_count\"]}')
    print(f'  Skills: {stats[\"skill_count\"]}')
    print(f'  Total: {stats[\"total_count\"]}')
except ImportError as e:
    print(f'Error: Required module not found - {e}')
except Exception as e:
    print(f'Error: {e}')
" 2>/dev/null
                    else
                        LOKI_NS_NAME="$name" python3 -c "
import os
try:
    from memory.storage import MemoryStorage
    name = os.environ.get('LOKI_NS_NAME', '')
    storage = MemoryStorage('.loki/memory', namespace=name)
    stats = storage.get_namespace_stats()
    print(f'Namespace: {stats[\"namespace\"]}')
    print(f'  Path: {stats[\"path\"]}')
    print(f'  Episodes: {stats[\"episode_count\"]}')
    print(f'  Patterns: {stats[\"pattern_count\"]}')
    print(f'  Skills: {stats[\"skill_count\"]}')
    print(f'  Total: {stats[\"total_count\"]}')
except ImportError as e:
    print(f'Error: Required module not found - {e}')
except Exception as e:
    print(f'Error: {e}')
" 2>/dev/null
                    fi
                    ;;

                copy)
                    # Copy from current namespace to target
                    local target="${1:-}"

                    if [ -z "$target" ]; then
                        echo "Usage: loki memory namespace copy <target-namespace>"
                        exit 1
                    fi

                    LOKI_NS_TARGET="$target" python3 -c "
import os
try:
    from memory.namespace import detect_namespace
    from memory.storage import MemoryStorage
    target = os.environ.get('LOKI_NS_TARGET', '')

    source_ns = detect_namespace()
    storage = MemoryStorage('.loki/memory', namespace=source_ns)
    result = storage.copy_to_namespace(target)

    print(f'Copied from {source_ns} to {target}:')
    print(f'  Episodes: {result[\"episodes\"]}')
    print(f'  Patterns: {result[\"patterns\"]}')
    print(f'  Skills: {result[\"skills\"]}')
except ImportError as e:
    print(f'Error: Required module not found - {e}')
except Exception as e:
    print(f'Error: {e}')
" 2>/dev/null
                    ;;

                merge)
                    # Merge from source namespace into current
                    local source="${1:-}"

                    if [ -z "$source" ]; then
                        echo "Usage: loki memory namespace merge <source-namespace>"
                        exit 1
                    fi

                    LOKI_NS_SOURCE="$source" python3 -c "
import os
try:
    from memory.namespace import detect_namespace
    from memory.storage import MemoryStorage
    source = os.environ.get('LOKI_NS_SOURCE', '')

    target_ns = detect_namespace()
    storage = MemoryStorage('.loki/memory', namespace=target_ns)
    result = storage.merge_from_namespace(source, deduplicate=True)

    print(f'Merged from {source} into {target_ns}:')
    print(f'  Episodes: {result[\"episodes\"]}')
    print(f'  Patterns: {result[\"patterns\"]}')
    print(f'  Skills: {result[\"skills\"]}')
except ImportError as e:
    print(f'Error: Required module not found - {e}')
except Exception as e:
    print(f'Error: {e}')
" 2>/dev/null
                    ;;

                help|--help|-h)
                    echo "Namespace management commands:"
                    echo ""
                    echo "  detect            Auto-detect namespace from current directory"
                    echo "  list              List all available namespaces"
                    echo "  create <name>     Create a new namespace"
                    echo "  delete <name>     Delete a namespace (--data to also delete data)"
                    echo "  stats [name]      Show stats for a namespace"
                    echo "  copy <target>     Copy current namespace to target"
                    echo "  merge <source>    Merge source namespace into current"
                    echo ""
                    echo "Examples:"
                    echo "  loki memory namespace detect"
                    echo "  loki memory namespace list"
                    echo "  loki memory namespace create my-project"
                    echo "  loki memory namespace create child-project parent-project"
                    echo "  loki memory namespace stats my-project"
                    echo "  loki memory namespace copy backup-ns"
                    echo "  loki memory namespace merge shared-patterns"
                    ;;

                *)
                    echo -e "${RED}Unknown namespace command: $ns_cmd${NC}"
                    echo "Run 'loki memory namespace help' for usage."
                    exit 1
                    ;;
            esac
            ;;

        --namespace|-n)
            # Global option to specify namespace for memory commands
            echo "Note: --namespace is a global option, use it before the subcommand:"
            echo "  loki memory --namespace=myproject retrieve 'query'"
            echo ""
            echo "Or use the namespace subcommand:"
            echo "  loki memory namespace stats myproject"
            ;;

        --help|-h|help)
            echo -e "${BOLD}loki memory${NC} - Manage cross-project learnings and memory system"
            echo ""
            echo "Usage: loki memory <command> [args]"
            echo ""
            echo "Learnings Commands:"
            echo "  list              Show summary of all learnings"
            echo "  show [type]       Show entries (patterns|mistakes|successes|all)"
            echo "                    Options: --limit N, --project P"
            echo "  search <query>    Search across all learnings"
            echo "  stats             Show statistics by project and category"
            echo "  export [file]     Export to JSON file"
            echo "  dedupe            Remove duplicate entries"
            echo "  clear [type]      Clear learnings (all or specific type)"
            echo ""
            echo "Memory System Commands:"
            echo "  index [rebuild]   Show or rebuild the memory index layer"
            echo "  timeline          Show timeline layer with temporal context"
            echo "  consolidate [h]   Run consolidation pipeline (default: 24 hours)"
            echo "  economics         Show token economics data"
            echo "  retrieve <query>  Test memory retrieval for a query"
            echo "  episode <id>      Show full episode by ID"
            echo "  pattern [id]      Show pattern by ID or list all patterns"
            echo "  skill [name]      Show skill by name or list all skills"
            echo "  vectors [rebuild] Show vector index stats or rebuild indices"
            echo ""
            echo "Namespace Commands (v5.19.0):"
            echo "  namespace detect       Auto-detect namespace from current directory"
            echo "  namespace list         List all available namespaces"
            echo "  namespace create NAME  Create a new namespace"
            echo "  namespace delete NAME  Delete a namespace"
            echo "  namespace stats [NAME] Show stats for a namespace"
            echo "  namespace copy TARGET  Copy current namespace to target"
            echo "  namespace merge SOURCE Merge source namespace into current"
            echo ""
            echo "Examples:"
            echo "  loki memory list"
            echo "  loki memory show mistakes --limit 10"
            echo "  loki memory show patterns --project myapp"
            echo "  loki memory search 'rate limit'"
            echo "  loki memory dedupe"
            echo "  loki memory export backup.json"
            echo ""
            echo "  loki memory index"
            echo "  loki memory index rebuild"
            echo "  loki memory consolidate 48"
            echo "  loki memory retrieve 'API rate limiting'"
            echo "  loki memory episode ep-20260202-abc123"
            echo "  loki memory pattern"
            echo "  loki memory pattern pat-api-error-handling"
            echo "  loki memory skill"
            echo "  loki memory vectors"
            echo "  loki memory vectors rebuild"
            echo ""
            echo "  loki memory namespace detect"
            echo "  loki memory namespace list"
            echo "  loki memory namespace create my-project"
            echo "  loki memory namespace stats"
            ;;

        *)
            echo -e "${RED}Unknown memory command: $subcommand${NC}"
            echo "Run 'loki memory help' for usage."
            exit 1
            ;;
    esac
}

# Knowledge Compounding - Structured Solutions (v5.30.0)
# Inspired by Compound Engineering Plugin's docs/solutions/ with YAML frontmatter
cmd_compound() {
    local subcommand="${1:-help}"
    shift 2>/dev/null || true

    local solutions_dir="${HOME}/.loki/solutions"

    case "$subcommand" in
        list|ls)
            echo -e "${BOLD}Compound Solutions${NC}"
            echo ""

            if [ ! -d "$solutions_dir" ]; then
                echo "  No solutions yet. Solutions are created automatically during"
                echo "  Loki sessions or manually with 'loki compound run'."
                echo ""
                echo "  Location: $solutions_dir"
                return
            fi

            local total=0
            for category in security performance architecture testing debugging deployment general; do
                local cat_dir="$solutions_dir/$category"
                if [ -d "$cat_dir" ]; then
                    local count=$(find "$cat_dir" -name "*.md" 2>/dev/null | wc -l | tr -d ' ')
                    if [ "$count" -gt 0 ]; then
                        printf "  %-16s ${GREEN}%d${NC} solutions\n" "$category" "$count"
                        total=$((total + count))
                    fi
                fi
            done

            if [ "$total" -eq 0 ]; then
                echo "  No solutions yet."
            else
                echo ""
                echo "  Total: ${total} solutions"
            fi
            echo ""
            echo "  Location: $solutions_dir"
            echo ""
            echo "  Use 'loki compound show <category>' to view solutions"
            ;;

        show)
            local category="${1:-}"
            if [ -z "$category" ]; then
                echo -e "${RED}Error: Specify a category${NC}"
                echo "Categories: security, performance, architecture, testing, debugging, deployment, general"
                return 1
            fi

            local cat_dir="$solutions_dir/$category"
            if [ ! -d "$cat_dir" ]; then
                echo "No solutions in category: $category"
                return
            fi

            echo -e "${BOLD}Solutions: $category${NC}"
            echo ""

            for file in "$cat_dir"/*.md; do
                [ -f "$file" ] || continue
                # Extract title from YAML frontmatter
                local title=$(grep '^title:' "$file" 2>/dev/null | head -1 | sed 's/title: *"//;s/"$//')
                local confidence=$(grep '^confidence:' "$file" 2>/dev/null | head -1 | sed 's/confidence: *//')
                local project=$(grep '^source_project:' "$file" 2>/dev/null | head -1 | sed 's/source_project: *"//;s/"$//')
                echo -e "  ${GREEN}*${NC} ${title:-$(basename "$file" .md)}"
                [ -n "$confidence" ] && echo -e "    confidence: ${confidence}  project: ${project:-unknown}"
            done
            echo ""
            ;;

        search)
            local query="${1:-}"
            if [ -z "$query" ]; then
                echo -e "${RED}Error: Specify a search query${NC}"
                echo "Usage: loki compound search <query>"
                return 1
            fi

            echo -e "${BOLD}Searching solutions for: ${query}${NC}"
            echo ""

            if [ ! -d "$solutions_dir" ]; then
                echo "No solutions directory found."
                return
            fi

            local found=0
            while IFS= read -r file; do
                local title=$(grep '^title:' "$file" 2>/dev/null | head -1 | sed 's/title: *"//;s/"$//')
                local category=$(grep '^category:' "$file" 2>/dev/null | head -1 | sed 's/category: *//')
                echo -e "  [${CYAN}${category}${NC}] ${title:-$(basename "$file" .md)}"
                echo -e "    ${DIM}${file}${NC}"
                found=$((found + 1))
            done < <(grep -rl "$query" "$solutions_dir" 2>/dev/null || true)

            if [ "$found" -eq 0 ]; then
                echo "  No solutions matching: $query"
            else
                echo ""
                echo "  Found: ${found} solutions"
            fi
            ;;

        run)
            echo -e "${BOLD}Compounding learnings into solutions...${NC}"
            echo ""

            local learnings_dir="${HOME}/.loki/learnings"
            if [ ! -d "$learnings_dir" ]; then
                echo "  No learnings directory found at: $learnings_dir"
                echo "  Run a Loki session first to generate learnings."
                return
            fi

            python3 << 'COMPOUND_RUN_SCRIPT'
import json, os, re
from datetime import datetime, timezone
from collections import defaultdict
learnings_dir = os.path.expanduser("~/.loki/learnings")
solutions_dir = os.path.expanduser("~/.loki/solutions")
CATEGORIES = ["security", "performance", "architecture", "testing", "debugging", "deployment", "general"]
CATEGORY_KEYWORDS = {
    "security": ["auth", "login", "password", "token", "injection", "xss", "csrf", "cors", "secret", "encrypt", "permission"],
    "performance": ["cache", "query", "n+1", "memory", "leak", "slow", "timeout", "pool", "index", "optimize", "bundle"],
    "architecture": ["pattern", "solid", "coupling", "abstraction", "module", "interface", "design", "refactor", "structure"],
    "testing": ["test", "mock", "fixture", "coverage", "assert", "spec", "e2e", "playwright", "jest", "flaky"],
    "debugging": ["debug", "error", "trace", "log", "stack", "crash", "exception", "breakpoint", "inspect"],
    "deployment": ["deploy", "docker", "ci", "cd", "pipeline", "kubernetes", "nginx", "ssl", "domain", "env", "config"],
}
def load_jsonl(filepath):
    entries = []
    if not os.path.exists(filepath): return entries
    with open(filepath, 'r') as f:
        for line in f:
            try:
                entry = json.loads(line)
                if 'description' in entry: entries.append(entry)
            except: continue
    return entries
def classify_category(description):
    desc_lower = description.lower()
    scores = {cat: sum(1 for kw in kws if kw in desc_lower) for cat, kws in CATEGORY_KEYWORDS.items()}
    best = max(scores, key=scores.get)
    return best if scores[best] > 0 else "general"
def slugify(text):
    return re.sub(r'[^a-z0-9]+', '-', text.lower().strip()).strip('-')[:80]
def solution_exists(solutions_dir, title_slug):
    for cat in CATEGORIES:
        cat_dir = os.path.join(solutions_dir, cat)
        if os.path.exists(cat_dir) and os.path.exists(os.path.join(cat_dir, f"{title_slug}.md")):
            return True
    return False
patterns = load_jsonl(os.path.join(learnings_dir, "patterns.jsonl"))
mistakes = load_jsonl(os.path.join(learnings_dir, "mistakes.jsonl"))
successes = load_jsonl(os.path.join(learnings_dir, "successes.jsonl"))
print(f"  Loaded: {len(patterns)} patterns, {len(mistakes)} mistakes, {len(successes)} successes")
grouped = defaultdict(list)
for entry in patterns + mistakes + successes:
    grouped[classify_category(entry.get('description', ''))].append(entry)
created = 0
now = datetime.now(timezone.utc).isoformat().replace("+00:00", "Z")
for category, entries in grouped.items():
    if len(entries) < 2: continue
    cat_dir = os.path.join(solutions_dir, category)
    os.makedirs(cat_dir, exist_ok=True)
    best_entry = max(entries, key=lambda e: len(e.get('description', '')))
    title = best_entry['description'][:120]
    slug = slugify(title)
    if solution_exists(solutions_dir, slug): continue
    all_words = ' '.join(e.get('description', '') for e in entries).lower()
    tags = []
    for kw_list in CATEGORY_KEYWORDS.values():
        for kw in kw_list:
            if kw in all_words and kw not in tags: tags.append(kw)
    tags = tags[:8]
    symptoms = [e.get('description', '')[:200] for e in entries
                if any(w in e.get('description', '').lower() for w in ['error', 'fail', 'bug', 'crash', 'issue'])][:4]
    if not symptoms: symptoms = [entries[0].get('description', '')[:200]]
    solution_lines = [f"- {e.get('description', '')}" for e in entries
                      if not any(w in e.get('description', '').lower() for w in ['error', 'fail', 'bug', 'crash'])]
    if not solution_lines: solution_lines = [f"- {entries[0].get('description', '')}"]
    project = best_entry.get('project', os.path.basename(os.getcwd()))
    filepath = os.path.join(cat_dir, f"{slug}.md")
    with open(filepath, 'w') as f:
        f.write(f"---\ntitle: \"{title}\"\ncategory: {category}\ntags: [{', '.join(tags)}]\nsymptoms:\n")
        for s in symptoms: f.write(f'  - "{s}"\n')
        f.write(f'root_cause: "Identified from {len(entries)} related learnings"\n')
        f.write(f'prevention: "See solution details below"\nconfidence: {min(0.5 + 0.1 * len(entries), 0.95):.2f}\n')
        f.write(f'source_project: "{project}"\ncreated: "{now}"\napplied_count: 0\n---\n\n')
        f.write("## Solution\n\n" + '\n'.join(solution_lines) + '\n\n')
        f.write(f"## Context\n\nCompounded from {len(entries)} learnings from project: {project}\n")
    created += 1
    print(f"  Created: {category}/{slug}.md")
if created > 0: print(f"\n  Compounded {created} new solution files to {solutions_dir}")
else: print("  No new solutions to compound (need 2+ related learnings per category)")
COMPOUND_RUN_SCRIPT
            ;;

        stats)
            echo -e "${BOLD}Compound Solution Statistics${NC}"
            echo ""

            if [ ! -d "$solutions_dir" ]; then
                echo "  No solutions directory found."
                return
            fi

            local total=0
            local newest=""
            local oldest=""

            for category in security performance architecture testing debugging deployment general; do
                local cat_dir="$solutions_dir/$category"
                if [ -d "$cat_dir" ]; then
                    local count=$(find "$cat_dir" -name "*.md" 2>/dev/null | wc -l | tr -d ' ')
                    total=$((total + count))
                fi
            done

            echo "  Total solutions: ${total}"

            if [ "$total" -gt 0 ]; then
                # Find newest and oldest
                newest=$(find "$solutions_dir" -name "*.md" -exec stat -f '%m %N' {} \; 2>/dev/null | sort -rn | head -1 | cut -d' ' -f2-)
                oldest=$(find "$solutions_dir" -name "*.md" -exec stat -f '%m %N' {} \; 2>/dev/null | sort -n | head -1 | cut -d' ' -f2-)

                if [ -n "$newest" ]; then
                    local newest_title=$(grep '^title:' "$newest" 2>/dev/null | head -1 | sed 's/title: *"//;s/"$//')
                    echo "  Newest: ${newest_title:-$(basename "$newest" .md)}"
                fi
                if [ -n "$oldest" ]; then
                    local oldest_title=$(grep '^title:' "$oldest" 2>/dev/null | head -1 | sed 's/title: *"//;s/"$//')
                    echo "  Oldest: ${oldest_title:-$(basename "$oldest" .md)}"
                fi
            fi

            echo ""
            echo "  Location: $solutions_dir"
            ;;

        help|--help|-h)
            echo -e "${BOLD}loki compound${NC} - Knowledge compounding system"
            echo ""
            echo "Extracts structured solutions from cross-project learnings."
            echo "Solutions are stored as markdown files with YAML frontmatter"
            echo "at ~/.loki/solutions/{category}/ and fed back into future planning."
            echo ""
            echo "Usage: loki compound <command>"
            echo ""
            echo "Commands:"
            echo "  list              List all solutions by category"
            echo "  show <category>   Show solutions in a category"
            echo "  search <query>    Search across all solutions"
            echo "  run               Manually compound current learnings into solutions"
            echo "  stats             Solution statistics"
            echo "  help              Show this help"
            echo ""
            echo "Categories: security, performance, architecture, testing,"
            echo "            debugging, deployment, general"
            echo ""
            echo "Solutions are created automatically at session end and"
            echo "loaded during the REASON phase for relevant tasks."
            ;;

        *)
            echo -e "${RED}Unknown compound command: $subcommand${NC}"
            echo "Run 'loki compound help' for usage."
            return 1
            ;;
    esac
}

# Checkpoint management - save and restore session state (v5.34.0)
cmd_checkpoint() {
    local subcommand="${1:-list}"
    shift 2>/dev/null || true

    local checkpoints_dir=".loki/state/checkpoints"
    local index_file="$checkpoints_dir/index.jsonl"

    case "$subcommand" in
        list|ls)
            echo -e "${BOLD}Session Checkpoints${NC}"
            echo ""

            if [ ! -f "$index_file" ]; then
                echo "  No checkpoints yet."
                echo ""
                echo "  Create one with: loki checkpoint create [message]"
                return 0
            fi

            local count=0
            local lines=()
            while IFS= read -r line; do
                lines+=("$line")
            done < "$index_file"

            # Show last 10 entries (most recent last)
            local total=${#lines[@]}
            local start=0
            if [ "$total" -gt 10 ]; then
                start=$((total - 10))
            fi

            printf "  ${DIM}%-14s %-20s %-10s %s${NC}\n" "ID" "TIMESTAMP" "GIT SHA" "MESSAGE"

            local i
            for (( i=start; i<total; i++ )); do
                local entry="${lines[$i]}"
                local cp_id=$(echo "$entry" | python3 -c "import sys,json; d=json.load(sys.stdin); print(d.get('id',''))" 2>/dev/null)
                local cp_ts=$(echo "$entry" | python3 -c "import sys,json; d=json.load(sys.stdin); print(d.get('timestamp','') or d.get('ts',''))" 2>/dev/null)
                local cp_sha=$(echo "$entry" | python3 -c "import sys,json; d=json.load(sys.stdin); print((d.get('git_sha','') or d.get('sha',''))[:8])" 2>/dev/null)
                local cp_msg=$(echo "$entry" | python3 -c "import sys,json; d=json.load(sys.stdin); print((d.get('message','') or d.get('task',''))[:50])" 2>/dev/null)

                if [ -n "$cp_id" ]; then
                    printf "  ${GREEN}%-14s${NC} %-20s ${CYAN}%-10s${NC} %s\n" "$cp_id" "$cp_ts" "$cp_sha" "$cp_msg"
                    count=$((count + 1))
                fi
            done

            if [ "$count" -eq 0 ]; then
                echo "  No valid checkpoints found."
            else
                echo ""
                echo "  Showing ${count} of ${total} checkpoints"
            fi
            ;;

        create)
            local raw_message="${*:-manual checkpoint}"
            # Escape backslashes and double quotes for JSON safety
            local message
            message=$(printf '%s' "$raw_message" | sed 's/\\/\\\\/g; s/"/\\"/g' | head -c 200)

            echo -e "${BOLD}Creating checkpoint...${NC}"
            echo ""

            # Ensure .loki exists
            if [ ! -d ".loki" ]; then
                echo -e "${RED}Error: No .loki directory found. Are you in a Loki project?${NC}"
                return 1
            fi

            # Capture git info
            local git_sha=""
            local git_branch=""
            if git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
                git_sha=$(git rev-parse HEAD 2>/dev/null || echo "unknown")
                git_branch=$(git branch --show-current 2>/dev/null || echo "unknown")
            else
                git_sha="not-a-git-repo"
                git_branch="none"
            fi

            # Generate checkpoint ID with timestamp
            local ts=$(date -u '+%Y%m%d-%H%M%S')
            local cp_id="cp-${ts}"
            local cp_dir="$checkpoints_dir/$cp_id"

            # Create checkpoint directory
            mkdir -p "$cp_dir"

            # Copy state files
            local copied=0
            for item in .loki/session.json .loki/dashboard-state.json .loki/queue .loki/memory .loki/metrics .loki/council; do
                if [ -e "$item" ]; then
                    cp -r "$item" "$cp_dir/" 2>/dev/null && copied=$((copied + 1))
                fi
            done

            # Write metadata (use python3 json.dumps for safe serialization)
            local iso_ts=$(date -u '+%Y-%m-%dT%H:%M:%SZ')
            # Truncate message to 500 chars to prevent abuse
            local safe_message="${message:0:500}"
            _CP_ID="$cp_id" _CP_TS="$iso_ts" _CP_SHA="$git_sha" _CP_BRANCH="$git_branch" \
            _CP_MSG="$safe_message" _CP_FILES="$copied" _CP_DIR="$cp_dir" _CP_INDEX="$index_file" \
            _CP_CHKDIR="$checkpoints_dir" python3 << 'WRITE_META_EOF'
import json, os
metadata = {
    "id": os.environ["_CP_ID"],
    "timestamp": os.environ["_CP_TS"],
    "git_sha": os.environ["_CP_SHA"],
    "git_branch": os.environ["_CP_BRANCH"],
    "message": os.environ["_CP_MSG"],
    "files_copied": int(os.environ["_CP_FILES"]),
    "created_by": "loki checkpoint create"
}
cp_dir = os.environ["_CP_DIR"]
os.makedirs(cp_dir, exist_ok=True)
with open(os.path.join(cp_dir, "metadata.json"), "w") as f:
    json.dump(metadata, f, indent=4)
index_file = os.environ["_CP_INDEX"]
os.makedirs(os.environ["_CP_CHKDIR"], exist_ok=True)
with open(index_file, "a") as f:
    index_entry = {
        "id": metadata["id"],
        "timestamp": metadata["timestamp"],
        "git_sha": metadata["git_sha"],
        "git_branch": metadata["git_branch"],
        "message": metadata["message"],
    }
    f.write(json.dumps(index_entry) + "\n")
WRITE_META_EOF

            echo -e "  Checkpoint: ${GREEN}$cp_id${NC}"
            echo -e "  Git SHA:    ${CYAN}${git_sha:0:8}${NC} ($git_branch)"
            echo -e "  Message:    $message"
            echo -e "  Files:      $copied state items copied"
            echo -e "  Location:   $cp_dir"
            echo ""
            echo "  Restore with: loki checkpoint rollback $cp_id"
            ;;

        show)
            local cp_id="${1:-}"
            if [ -z "$cp_id" ]; then
                echo -e "${RED}Error: Specify a checkpoint ID${NC}"
                echo "Usage: loki checkpoint show <id>"
                echo "Run 'loki checkpoint list' to see available checkpoints."
                return 1
            fi

            # Validate checkpoint ID (prevent path traversal)
            if [[ ! "$cp_id" =~ ^[a-zA-Z0-9_-]+$ ]]; then
                echo -e "${RED}Error: Invalid checkpoint ID (must be alphanumeric, hyphens, underscores only)${NC}"
                return 1
            fi

            local cp_dir="$checkpoints_dir/$cp_id"
            local metadata="$cp_dir/metadata.json"

            if [ ! -f "$metadata" ]; then
                echo -e "${RED}Error: Checkpoint not found: $cp_id${NC}"
                echo "Run 'loki checkpoint list' to see available checkpoints."
                return 1
            fi

            echo -e "${BOLD}Checkpoint: $cp_id${NC}"
            echo ""

            _CP_METADATA="$metadata" python3 << 'SHOW_EOF'
import json, os
with open(os.environ["_CP_METADATA"], "r") as f:
    d = json.load(f)
print(f"  ID:         {d.get('id', 'unknown')}")
print(f"  Timestamp:  {d.get('timestamp', 'unknown')}")
print(f"  Git SHA:    {d.get('git_sha', 'unknown')}")
print(f"  Git Branch: {d.get('git_branch', 'unknown')}")
print(f"  Message:    {d.get('message', 'none')}")
print(f"  Files:      {d.get('files_copied', 0)} state items")
print(f"  Created By: {d.get('created_by', 'unknown')}")
SHOW_EOF

            echo ""
            echo "  Contents:"
            for item in "$cp_dir"/*; do
                [ -e "$item" ] || continue
                local name=$(basename "$item")
                [ "$name" = "metadata.json" ] && continue
                if [ -d "$item" ]; then
                    local fcount=$(find "$item" -type f 2>/dev/null | wc -l | tr -d ' ')
                    echo -e "    ${DIM}[dir]${NC}  $name/ ($fcount files)"
                else
                    local fsize=$(wc -c < "$item" 2>/dev/null | tr -d ' ')
                    echo -e "    ${DIM}[file]${NC} $name (${fsize} bytes)"
                fi
            done
            ;;

        rollback)
            local cp_id="${1:-}"
            if [ -z "$cp_id" ]; then
                echo -e "${RED}Error: Specify a checkpoint ID${NC}"
                echo "Usage: loki checkpoint rollback <id>"
                echo "Run 'loki checkpoint list' to see available checkpoints."
                return 1
            fi

            # Validate checkpoint ID (prevent path traversal)
            if [[ ! "$cp_id" =~ ^[a-zA-Z0-9_-]+$ ]]; then
                echo -e "${RED}Error: Invalid checkpoint ID (must be alphanumeric, hyphens, underscores only)${NC}"
                return 1
            fi

            local cp_dir="$checkpoints_dir/$cp_id"
            local metadata="$cp_dir/metadata.json"

            if [ ! -f "$metadata" ]; then
                echo -e "${RED}Error: Checkpoint not found: $cp_id${NC}"
                echo "Run 'loki checkpoint list' to see available checkpoints."
                return 1
            fi

            echo -e "${BOLD}Rolling back to checkpoint: $cp_id${NC}"
            echo ""

            # Restore state files
            local restored=0
            for item in "$cp_dir"/*; do
                [ -e "$item" ] || continue
                local name=$(basename "$item")
                [ "$name" = "metadata.json" ] && continue

                if [ -d "$item" ]; then
                    rm -rf ".loki/$name"
                    cp -r "$item" ".loki/$name" 2>/dev/null && restored=$((restored + 1))
                else
                    cp "$item" ".loki/$name" 2>/dev/null && restored=$((restored + 1))
                fi
            done

            echo -e "  Restored: ${GREEN}$restored${NC} state items from $cp_id"

            # Show git info for manual code rollback
            local cp_sha=$(_CP_METADATA="$metadata" python3 -c "import json, os; d=json.load(open(os.environ['_CP_METADATA'])); print(d.get('git_sha','unknown'))" 2>/dev/null)
            if [ -n "$cp_sha" ] && [ "$cp_sha" != "unknown" ] && [ "$cp_sha" != "not-a-git-repo" ]; then
                echo ""
                echo -e "  ${YELLOW}Note:${NC} Session state has been restored, but code is unchanged."
                echo "  To also roll back code to the checkpoint's git state:"
                echo ""
                echo -e "    ${DIM}git reset --hard ${cp_sha:0:8}${NC}"
                echo ""
                echo -e "  ${RED}Warning:${NC} git reset --hard will discard uncommitted changes."
                echo "  Consider 'git stash' first to preserve current work."
            fi
            ;;

        help|--help|-h)
            echo -e "${BOLD}loki checkpoint${NC} - Session state checkpoints"
            echo ""
            echo "Save and restore session state snapshots during autonomous runs."
            echo "Checkpoints capture .loki/ state files and record the git SHA"
            echo "at the time of creation."
            echo ""
            echo "Usage: loki checkpoint <command> [args]"
            echo "       loki cp <command> [args]"
            echo ""
            echo "Commands:"
            echo "  list              List recent checkpoints (default)"
            echo "  create [message]  Create a new checkpoint"
            echo "  show <id>         Show checkpoint details"
            echo "  rollback <id>     Restore state from a checkpoint"
            echo "  help              Show this help"
            echo ""
            echo "Examples:"
            echo "  loki checkpoint create 'before refactor'"
            echo "  loki cp list"
            echo "  loki cp show cp-20260212-143022"
            echo "  loki cp rollback cp-20260212-143022"
            ;;

        *)
            echo -e "${RED}Unknown checkpoint command: $subcommand${NC}"
            echo "Run 'loki checkpoint help' for usage."
            return 1
            ;;
    esac
}

# Completion Council management
cmd_council() {
    local subcommand="${1:-status}"
    shift 2>/dev/null || true

    local council_dir=".loki/council"

    case "$subcommand" in
        status)
            echo -e "${CYAN}=== Completion Council Status ===${NC}"

            if [ ! -d "$council_dir" ]; then
                echo -e "${YELLOW}Council not initialized (no active session)${NC}"
                return 0
            fi

            if [ -f "$council_dir/state.json" ]; then
                LOKI_COUNCIL_STATE="$council_dir/state.json" python3 -c "
import json, os
with open(os.environ['LOKI_COUNCIL_STATE']) as f:
    state = json.load(f)
print(f\"Enabled: {state.get('initialized', False)}\")
print(f\"Total votes: {state.get('total_votes', 0)}\")
print(f\"Approve votes: {state.get('approve_votes', 0)}\")
print(f\"Reject votes: {state.get('reject_votes', 0)}\")
print(f\"Stagnation streak: {state.get('consecutive_no_change', 0)}\")
print(f\"Done signals: {state.get('done_signals', 0)}\")
print(f\"Last check: iteration {state.get('last_check_iteration', 'none')}\")
verdicts = state.get('verdicts', [])
if verdicts:
    print(f\"\nRecent verdicts:\")
    for v in verdicts[-5:]:
        print(f\"  Iteration {v['iteration']}: {v['result']} ({v['approve']} approve / {v['reject']} reject)\")
else:
    print(f\"\nNo verdicts yet\")
" 2>/dev/null
            else
                echo "Council state file not found"
            fi
            ;;

        verdicts|log)
            echo -e "${CYAN}=== Council Decision Log ===${NC}"

            if [ -f "$council_dir/state.json" ]; then
                LOKI_COUNCIL_STATE="$council_dir/state.json" python3 -c "
import json, os
with open(os.environ['LOKI_COUNCIL_STATE']) as f:
    state = json.load(f)
verdicts = state.get('verdicts', [])
if not verdicts:
    print('No decisions recorded yet')
else:
    for v in verdicts:
        result = v.get('result', 'UNKNOWN')
        color = '\033[32m' if result == 'APPROVED' else '\033[31m'
        print(f\"{color}{result}\033[0m - Iteration {v['iteration']} ({v.get('timestamp', 'unknown')}) - {v['approve']} approve / {v['reject']} reject\")
" 2>/dev/null
            else
                echo "No council data available"
            fi
            ;;

        convergence)
            echo -e "${CYAN}=== Convergence Tracking ===${NC}"

            if [ -f "$council_dir/convergence.log" ]; then
                echo "Timestamp | Iteration | Files Changed | No-Change Streak | Done Signals"
                echo "----------|-----------|---------------|-----------------|-------------"
                tail -20 "$council_dir/convergence.log" | while IFS='|' read -r ts iter files streak signals; do
                    printf "%-10s| %-9s | %-13s | %-15s | %s\n" "$ts" "$iter" "$files" "$streak" "$signals"
                done
            else
                echo "No convergence data available"
            fi
            ;;

        force-review)
            echo "Requesting immediate council review..."
            mkdir -p ".loki/signals"
            echo "$(date -u +"%Y-%m-%dT%H:%M:%SZ")" > ".loki/signals/COUNCIL_REVIEW_REQUESTED"
            echo -e "${GREEN}Review requested. Council will convene at next iteration.${NC}"
            ;;

        report)
            if [ -f "$council_dir/report.md" ]; then
                cat "$council_dir/report.md"
            else
                echo "No completion report available yet"
            fi
            ;;

        config)
            echo -e "${CYAN}=== Council Configuration ===${NC}"
            echo "LOKI_COUNCIL_ENABLED=${LOKI_COUNCIL_ENABLED:-true}"
            echo "LOKI_COUNCIL_SIZE=${LOKI_COUNCIL_SIZE:-3}"
            echo "LOKI_COUNCIL_THRESHOLD=${LOKI_COUNCIL_THRESHOLD:-2}"
            echo "LOKI_COUNCIL_CHECK_INTERVAL=${LOKI_COUNCIL_CHECK_INTERVAL:-5}"
            echo "LOKI_COUNCIL_MIN_ITERATIONS=${LOKI_COUNCIL_MIN_ITERATIONS:-3}"
            echo "LOKI_COUNCIL_STAGNATION_LIMIT=${LOKI_COUNCIL_STAGNATION_LIMIT:-5}"
            ;;

        help|--help|-h)
            echo "Usage: loki council <command>"
            echo ""
            echo "Commands:"
            echo "  status         Show council status (default)"
            echo "  verdicts       Show decision log (alias: log)"
            echo "  convergence    Show convergence tracking data"
            echo "  force-review   Request immediate council review"
            echo "  report         Show completion report"
            echo "  config         Show council configuration"
            echo "  help           Show this help"
            ;;

        *)
            echo -e "${RED}Unknown council command: $subcommand${NC}"
            echo "Run 'loki council help' for usage."
            exit 1
            ;;
    esac
}

# Cross-project registry management
cmd_projects() {
    local subcommand="${1:-list}"
    local registry_dir="${HOME}/.loki/dashboard"
    local registry_file="${registry_dir}/projects.json"

    # Ensure directory exists
    mkdir -p "$registry_dir"

    # Initialize empty registry if needed
    if [ ! -f "$registry_file" ]; then
        echo '{"version":"1.0","projects":{}}' > "$registry_file"
    fi

    case "$subcommand" in
        list|ls)
            echo -e "${BOLD}Registered Projects${NC}"
            echo ""

            python3 -c "
import json
import os
from datetime import datetime

registry_file = '$registry_file'
if os.path.exists(registry_file):
    with open(registry_file, 'r') as f:
        data = json.load(f)
        projects = data.get('projects', {})
        if not projects:
            print('  (no projects registered)')
            print('')
            print('Use \"loki projects add <path>\" to register a project')
        else:
            # Sort by last accessed
            sorted_projects = sorted(
                projects.values(),
                key=lambda p: p.get('last_accessed') or p.get('registered_at', ''),
                reverse=True
            )
            for p in sorted_projects:
                status_icon = '[OK]' if os.path.isdir(p['path']) else '[MISSING]'
                alias = f\" ({p['alias']})\" if p.get('alias') else ''
                print(f\"  {status_icon} {p['name']}{alias}\")
                print(f\"      Path: {p['path']}\")
                if p.get('last_accessed'):
                    print(f\"      Last accessed: {p['last_accessed'][:10]}\")
                print()
else:
    print('  (no projects registered)')
" 2>/dev/null
            ;;

        add)
            local path="${2:-$(pwd)}"
            local name=""
            local alias=""
            shift 2 2>/dev/null || shift 1 2>/dev/null || true

            # Parse optional args
            while [[ $# -gt 0 ]]; do
                case "$1" in
                    --name|-n)
                        name="${2:-}"
                        shift 2
                        ;;
                    --alias|-a)
                        alias="${2:-}"
                        shift 2
                        ;;
                    *)
                        shift
                        ;;
                esac
            done

            # Resolve path
            path=$(cd "$path" 2>/dev/null && pwd || echo "$path")

            if [ ! -d "$path" ]; then
                echo -e "${RED}Error: Path does not exist: $path${NC}"
                exit 1
            fi

            python3 -c "
import json
import os
import hashlib
from datetime import datetime, timezone

registry_file = '$registry_file'
path = '$path'
name = '$name' or os.path.basename(path)
alias = '$alias' or None

# Generate project ID
project_id = hashlib.md5(path.encode()).hexdigest()[:12]

# Load registry
with open(registry_file, 'r') as f:
    data = json.load(f)

projects = data.get('projects', {})
now = datetime.now(timezone.utc).isoformat()

if project_id in projects:
    # Update existing
    projects[project_id]['name'] = name
    if alias:
        projects[project_id]['alias'] = alias
    projects[project_id]['updated_at'] = now
    print(f'Updated: {name}')
else:
    # Add new
    projects[project_id] = {
        'id': project_id,
        'path': path,
        'name': name,
        'alias': alias,
        'registered_at': now,
        'updated_at': now,
        'last_accessed': None,
        'has_loki_dir': os.path.isdir(os.path.join(path, '.loki')),
        'status': 'active',
    }
    print(f'Registered: {name}')

data['projects'] = projects
with open(registry_file, 'w') as f:
    json.dump(data, f, indent=2)

print(f'  Path: {path}')
if alias:
    print(f'  Alias: {alias}')
" 2>/dev/null
            ;;

        remove|rm)
            local identifier="${2:-}"

            if [ -z "$identifier" ]; then
                echo -e "${RED}Error: Specify project ID, path, or alias${NC}"
                exit 1
            fi

            python3 -c "
import json
import os

registry_file = '$registry_file'
identifier = '$identifier'

with open(registry_file, 'r') as f:
    data = json.load(f)

projects = data.get('projects', {})
found_id = None

for pid, project in projects.items():
    if pid == identifier or project['path'] == identifier or project.get('alias') == identifier:
        found_id = pid
        break

if found_id:
    name = projects[found_id]['name']
    del projects[found_id]
    data['projects'] = projects
    with open(registry_file, 'w') as f:
        json.dump(data, f, indent=2)
    print(f'Removed: {name}')
else:
    print(f'Not found: {identifier}')
    exit(1)
" 2>/dev/null
            ;;

        discover)
            echo -e "${BOLD}Discovering Projects${NC}"
            echo ""

            python3 -c "
import os
from pathlib import Path

home = Path.home()
search_paths = [
    home / 'git',
    home / 'projects',
    home / 'code',
    home / 'dev',
    home / 'workspace',
    home / 'src',
]

discovered = []

def search_dir(path, depth=0, max_depth=3):
    if depth > max_depth:
        return
    try:
        if not path.is_dir():
            return
        loki_dir = path / '.loki'
        if loki_dir.is_dir():
            discovered.append({
                'path': str(path),
                'name': path.name,
                'has_state': (loki_dir / 'state' / 'session.json').exists(),
            })
            return
        for child in path.iterdir():
            if child.is_dir() and not child.name.startswith('.'):
                search_dir(child, depth + 1, max_depth)
    except (PermissionError, OSError):
        pass

for search_path in search_paths:
    if search_path.exists():
        search_dir(search_path)

if not discovered:
    print('  No projects with .loki directories found')
else:
    print(f'  Found {len(discovered)} project(s):')
    print('')
    for p in discovered:
        status = '[active]' if p['has_state'] else '[idle]'
        print(f\"  {status} {p['name']}\")
        print(f\"      {p['path']}\")
        print()
    print('Use \"loki projects sync\" to register all discovered projects')
" 2>/dev/null
            ;;

        sync)
            echo -e "${BOLD}Syncing Project Registry${NC}"
            echo ""

            python3 -c "
import json
import os
import hashlib
from pathlib import Path
from datetime import datetime, timezone

registry_file = '$registry_file'
home = Path.home()

# Load registry
with open(registry_file, 'r') as f:
    data = json.load(f)
projects = data.get('projects', {})

# Discover projects
search_paths = [
    home / 'git',
    home / 'projects',
    home / 'code',
    home / 'dev',
    home / 'workspace',
    home / 'src',
]

discovered = []

def search_dir(path, depth=0, max_depth=3):
    if depth > max_depth:
        return
    try:
        if not path.is_dir():
            return
        loki_dir = path / '.loki'
        if loki_dir.is_dir():
            discovered.append(str(path))
            return
        for child in path.iterdir():
            if child.is_dir() and not child.name.startswith('.'):
                search_dir(child, depth + 1, max_depth)
    except (PermissionError, OSError):
        pass

for search_path in search_paths:
    if search_path.exists():
        search_dir(search_path)

# Add new projects
added = 0
now = datetime.now(timezone.utc).isoformat()

for path in discovered:
    project_id = hashlib.md5(path.encode()).hexdigest()[:12]
    if project_id not in projects:
        projects[project_id] = {
            'id': project_id,
            'path': path,
            'name': os.path.basename(path),
            'alias': None,
            'registered_at': now,
            'updated_at': now,
            'last_accessed': None,
            'has_loki_dir': True,
            'status': 'active',
        }
        added += 1
        print(f'  Added: {os.path.basename(path)}')

# Check for missing
missing = 0
for pid, project in list(projects.items()):
    if not os.path.isdir(project['path']):
        project['status'] = 'missing'
        missing += 1

data['projects'] = projects
with open(registry_file, 'w') as f:
    json.dump(data, f, indent=2)

print('')
print(f'Added: {added}, Missing: {missing}, Total: {len(projects)}')
" 2>/dev/null
            ;;

        health)
            local identifier="${2:-$(pwd)}"

            python3 -c "
import json
import os

registry_file = '$registry_file'
identifier = '$identifier'

# If it's a path, resolve it
if os.path.isdir(identifier):
    identifier = os.path.abspath(identifier)

with open(registry_file, 'r') as f:
    data = json.load(f)

projects = data.get('projects', {})
project = None

for p in projects.values():
    if p['id'] == identifier or p['path'] == identifier or p.get('alias') == identifier:
        project = p
        break

if not project:
    print(f'Project not found: {identifier}')
    exit(1)

path = project['path']
checks = {
    'Path exists': os.path.isdir(path),
    '.loki dir exists': os.path.isdir(os.path.join(path, '.loki')),
    'Session state': os.path.isfile(os.path.join(path, '.loki', 'state', 'session.json')),
    'PRD exists': any(
        os.path.isfile(os.path.join(path, f))
        for f in ['PRD.md', 'prd.md', 'docs/PRD.md', 'docs/prd.md']
    ),
}

print(f\"Project: {project['name']}\")
print(f\"Path: {path}\")
print('')
print('Health Checks:')
for check, passed in checks.items():
    icon = '[OK]' if passed else '[FAIL]'
    print(f'  {icon} {check}')
" 2>/dev/null
            ;;

        --help|-h|help)
            echo -e "${BOLD}loki projects${NC} - Manage cross-project registry"
            echo ""
            echo "Usage: loki projects <command> [args]"
            echo ""
            echo "Commands:"
            echo "  list              List all registered projects"
            echo "  add <path>        Register a project"
            echo "  remove <id>       Remove a project from registry"
            echo "  discover          Find projects with .loki directories"
            echo "  sync              Auto-discover and register projects"
            echo "  health <id>       Check project health status"
            echo ""
            echo "Options for 'add':"
            echo "  --name, -n        Display name for the project"
            echo "  --alias, -a       Short alias for quick access"
            echo ""
            echo "Examples:"
            echo "  loki projects list"
            echo "  loki projects add . --alias myapp"
            echo "  loki projects add ~/git/project --name 'My Project'"
            echo "  loki projects discover"
            echo "  loki projects sync"
            echo "  loki projects health myapp"
            ;;

        *)
            echo -e "${RED}Unknown projects command: $subcommand${NC}"
            echo "Run 'loki projects help' for usage."
            exit 1
            ;;
    esac
}

# Voice input commands
cmd_voice() {
    local subcommand="${1:-status}"
    local VOICE_SCRIPT="$SKILL_DIR/autonomy/voice.sh"

    # Check fallback locations for voice script
    if [ ! -f "$VOICE_SCRIPT" ]; then
        # Try relative to loki CLI location
        local loki_dir
        loki_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
        VOICE_SCRIPT="$loki_dir/voice.sh"
    fi

    if [ ! -f "$VOICE_SCRIPT" ]; then
        echo -e "${RED}Error: Voice module not found${NC}"
        echo "Expected at: $SKILL_DIR/autonomy/voice.sh"
        echo ""
        echo "Voice input requires the voice.sh module."
        echo "This feature may not be available in all installations."
        exit 1
    fi

    case "$subcommand" in
        status)
            "$VOICE_SCRIPT" status
            ;;
        listen)
            echo -e "${BOLD}Starting voice input...${NC}"
            local text
            text=$("$VOICE_SCRIPT" listen)
            if [ -n "$text" ]; then
                echo ""
                echo -e "${GREEN}Transcribed text:${NC}"
                echo "$text"
            fi
            ;;
        dictate)
            local output="${2:-prd-voice.md}"
            echo -e "${BOLD}Starting guided PRD dictation...${NC}"
            echo ""
            "$VOICE_SCRIPT" dictate "$output"
            if [ -f "$output" ]; then
                echo ""
                echo -e "${GREEN}PRD created: $output${NC}"
                echo ""
                echo "Start Loki Mode with:"
                echo "  loki start $output"
            fi
            ;;
        speak)
            shift
            if [ $# -eq 0 ]; then
                echo -e "${RED}Usage: loki voice speak MESSAGE${NC}"
                exit 1
            fi
            "$VOICE_SCRIPT" speak "$*"
            ;;
        start)
            # Dictate PRD and start Loki Mode
            local prd_file="${2:-prd-voice-$(date +%Y%m%d%H%M%S).md}"
            echo -e "${BOLD}Voice-activated PRD creation...${NC}"
            "$VOICE_SCRIPT" dictate "$prd_file"
            if [ -f "$prd_file" ]; then
                echo ""
                echo -e "${GREEN}PRD created. Starting Loki Mode...${NC}"
                cmd_start "$prd_file"
            fi
            ;;
        --help|-h|help)
            echo -e "${BOLD}loki voice${NC} - Voice input for PRD creation"
            echo ""
            echo "Usage: loki voice <command> [options]"
            echo ""
            echo "Commands:"
            echo "  status           Check voice input capabilities"
            echo "  listen           Listen and transcribe voice input"
            echo "  dictate [FILE]   Guided PRD dictation (default: prd-voice.md)"
            echo "  speak MESSAGE    Text-to-speech output"
            echo "  start [FILE]     Dictate PRD and start Loki Mode immediately"
            echo ""
            echo "Requirements:"
            echo "  macOS: Enable Dictation in System Settings > Keyboard"
            echo "  Or: Set OPENAI_API_KEY for Whisper API transcription"
            echo "  Or: pip install openai-whisper for local transcription"
            ;;
        *)
            echo -e "${RED}Unknown voice command: $subcommand${NC}"
            echo "Run 'loki voice help' for usage."
            exit 1
            ;;
    esac
}

# Enterprise features (optional - requires env vars)
cmd_enterprise() {
    local subcommand="${1:-status}"
    local token_dir="${HOME}/.loki/dashboard"
    local token_file="${token_dir}/tokens.json"

    # Ensure directory exists
    mkdir -p "$token_dir"

    # Initialize empty tokens if needed
    if [ ! -f "$token_file" ]; then
        echo '{"version":"1.0","tokens":{}}' > "$token_file"
        chmod 600 "$token_file"
    fi

    case "$subcommand" in
        status)
            echo -e "${BOLD}Enterprise Features Status${NC}"
            echo ""

            local auth_enabled="${LOKI_ENTERPRISE_AUTH:-false}"
            local audit_disabled="${LOKI_AUDIT_DISABLED:-false}"
            local audit_force_on="${LOKI_ENTERPRISE_AUDIT:-false}"

            if [ "$auth_enabled" = "true" ] || [ "$auth_enabled" = "1" ]; then
                echo -e "  Token Auth:     ${GREEN}Enabled${NC}"
            else
                echo -e "  Token Auth:     ${DIM}Disabled${NC}"
            fi

            # OIDC/SSO status
            local oidc_issuer="${LOKI_OIDC_ISSUER:-}"
            local oidc_client="${LOKI_OIDC_CLIENT_ID:-}"
            if [ -n "$oidc_issuer" ] && [ -n "$oidc_client" ]; then
                echo -e "  OIDC/SSO:       ${GREEN}Enabled${NC} (${oidc_issuer})"
            else
                echo -e "  OIDC/SSO:       ${DIM}Disabled${NC}"
            fi

            # Audit is on by default; disabled only if LOKI_AUDIT_DISABLED=true
            if [ "$audit_force_on" = "true" ] || [ "$audit_force_on" = "1" ]; then
                echo -e "  Audit Logging:  ${GREEN}Enabled (enterprise)${NC}"
            elif [ "$audit_disabled" = "true" ] || [ "$audit_disabled" = "1" ]; then
                echo -e "  Audit Logging:  ${DIM}Disabled${NC}"
            else
                echo -e "  Audit Logging:  ${GREEN}Enabled (default)${NC}"
            fi

            echo ""
            echo "Configure with environment variables:"
            echo "  export LOKI_ENTERPRISE_AUTH=true     # Token authentication"
            echo "  export LOKI_AUDIT_DISABLED=true      # Disable audit logging"
            echo "  export LOKI_ENTERPRISE_AUDIT=true    # Force audit on (legacy)"
            echo ""
            echo "OIDC/SSO (optional, works alongside token auth):"
            echo "  export LOKI_OIDC_ISSUER=https://accounts.google.com"
            echo "  export LOKI_OIDC_CLIENT_ID=your-client-id"
            echo "  export LOKI_OIDC_AUDIENCE=your-audience    # Optional, defaults to client_id"
            ;;

        token)
            local token_cmd="${2:-list}"
            shift 2 2>/dev/null || shift 1 2>/dev/null || true

            case "$token_cmd" in
                generate|create|new)
                    local name="${1:-}"
                    local scopes=""
                    local expires=""

                    if [ -z "$name" ]; then
                        echo -e "${RED}Error: Token name required${NC}"
                        echo "Usage: loki enterprise token generate <name> [--scopes '*'] [--expires 30]"
                        exit 1
                    fi

                    # Validate name is not a flag
                    if [[ "$name" == -* ]]; then
                        echo -e "${RED}Error: Token name cannot start with '-'${NC}"
                        echo "Usage: loki enterprise token generate <name> [--scopes '*'] [--expires 30]"
                        exit 1
                    fi

                    # Warn if enterprise auth is not enabled
                    local auth_enabled="${LOKI_ENTERPRISE_AUTH:-false}"
                    if [ "$auth_enabled" != "true" ] && [ "$auth_enabled" != "1" ]; then
                        echo -e "${YELLOW}Warning: LOKI_ENTERPRISE_AUTH is not enabled${NC}"
                        echo "Tokens can be generated but won't work for API authentication."
                        echo "Enable with: export LOKI_ENTERPRISE_AUTH=true"
                        echo ""
                    fi

                    shift

                    while [[ $# -gt 0 ]]; do
                        case "$1" in
                            --scopes|-s)
                                scopes="${2:-}"
                                shift 2
                                ;;
                            --expires|-e)
                                expires="${2:-}"
                                shift 2
                                ;;
                            *)
                                shift
                                ;;
                        esac
                    done

                    python3 -c "
import json
import secrets
import hashlib
from datetime import datetime, timezone, timedelta
import os

token_file = '$token_file'
name = '$name'
scopes_str = '$scopes'
expires_str = '$expires'

# Parse scopes
scopes = scopes_str.split(',') if scopes_str else ['*']

# Parse expiration
expires_at = None
if expires_str:
    days = int(expires_str)
    expires_at = (datetime.now(timezone.utc) + timedelta(days=days)).isoformat()

# Generate token
raw_token = f'loki_{secrets.token_urlsafe(32)}'
token_hash = hashlib.sha256(raw_token.encode()).hexdigest()
token_id = token_hash[:12]

# Load tokens
with open(token_file, 'r') as f:
    data = json.load(f)

tokens = data.get('tokens', {})

# Check duplicate name
for existing in tokens.values():
    if existing.get('name') == name:
        print(f'Error: Token with name \"{name}\" already exists')
        exit(1)

# Create token entry
tokens[token_id] = {
    'id': token_id,
    'name': name,
    'hash': token_hash,
    'scopes': scopes,
    'created_at': datetime.now(timezone.utc).isoformat(),
    'expires_at': expires_at,
    'last_used': None,
    'revoked': False,
}

data['tokens'] = tokens
with open(token_file, 'w') as f:
    json.dump(data, f, indent=2)

# Set restrictive permissions
os.chmod(token_file, 0o600)

print(f'Token created: {name}')
print(f'ID: {token_id}')
print(f'Scopes: {scopes}')
if expires_at:
    print(f'Expires: {expires_at[:10]}')
print('')
print('Token (save this - shown only once):')
print(f'  {raw_token}')
" 2>/dev/null
                    ;;

                list|ls)
                    local include_revoked="false"
                    if [ "${1:-}" = "--all" ] || [ "${1:-}" = "--include-revoked" ]; then
                        include_revoked="true"
                    fi

                    echo -e "${BOLD}API Tokens${NC}"
                    if [ "$include_revoked" = "true" ]; then
                        echo -e "${DIM}(including revoked)${NC}"
                    fi
                    echo ""

                    python3 -c "
import json
import os

token_file = '$token_file'
include_revoked = '$include_revoked' == 'true'

with open(token_file, 'r') as f:
    data = json.load(f)

tokens = data.get('tokens', {})
if include_revoked:
    token_list = list(tokens.values())
else:
    token_list = [t for t in tokens.values() if not t.get('revoked')]

if not token_list:
    print('  (no tokens)')
    if not include_revoked:
        print('')
        print('  Use --all to include revoked tokens')
else:
    for t in token_list:
        if t.get('revoked'):
            status = '[REVOKED]'
        elif t.get('expires_at'):
            from datetime import datetime, timezone
            expires = datetime.fromisoformat(t['expires_at'])
            if datetime.now(timezone.utc) > expires:
                status = '[EXPIRED]'
            else:
                status = '[OK]'
        else:
            status = '[OK]'
        print(f\"  {status} {t['name']} ({t['id']})\")
        print(f\"      Scopes: {', '.join(t['scopes'])}\")
        if t.get('created_at'):
            print(f\"      Created: {t['created_at'][:10]}\")
        if t.get('expires_at'):
            print(f\"      Expires: {t['expires_at'][:10]}\")
        if t.get('last_used'):
            print(f\"      Last used: {t['last_used'][:10]}\")
        print()
" 2>/dev/null
                    ;;

                revoke)
                    local identifier="${1:-}"

                    if [ -z "$identifier" ]; then
                        echo -e "${RED}Error: Token ID or name required${NC}"
                        exit 1
                    fi

                    python3 -c "
import json
from datetime import datetime, timezone

token_file = '$token_file'
identifier = '$identifier'

with open(token_file, 'r') as f:
    data = json.load(f)

tokens = data.get('tokens', {})
found_id = None

for tid, token in tokens.items():
    if tid == identifier or token.get('name') == identifier:
        found_id = tid
        break

if found_id:
    tokens[found_id]['revoked'] = True
    tokens[found_id]['revoked_at'] = datetime.now(timezone.utc).isoformat()
    data['tokens'] = tokens
    with open(token_file, 'w') as f:
        json.dump(data, f, indent=2)
    print(f'Revoked: {tokens[found_id][\"name\"]}')
else:
    print(f'Token not found: {identifier}')
    exit(1)
" 2>/dev/null
                    ;;

                delete)
                    local identifier="${1:-}"

                    if [ -z "$identifier" ]; then
                        echo -e "${RED}Error: Token ID or name required${NC}"
                        exit 1
                    fi

                    python3 -c "
import json

token_file = '$token_file'
identifier = '$identifier'

with open(token_file, 'r') as f:
    data = json.load(f)

tokens = data.get('tokens', {})
found_id = None
found_name = None

for tid, token in tokens.items():
    if tid == identifier or token.get('name') == identifier:
        found_id = tid
        found_name = token.get('name')
        break

if found_id:
    del tokens[found_id]
    data['tokens'] = tokens
    with open(token_file, 'w') as f:
        json.dump(data, f, indent=2)
    print(f'Deleted: {found_name}')
else:
    print(f'Token not found: {identifier}')
    exit(1)
" 2>/dev/null
                    ;;

                *)
                    echo -e "${RED}Unknown token command: $token_cmd${NC}"
                    echo ""
                    echo "Usage: loki enterprise token <command>"
                    echo ""
                    echo "Commands:"
                    echo "  generate <name>   Create a new API token"
                    echo "  list              List all active tokens"
                    echo "  revoke <id>       Revoke a token (keeps record)"
                    echo "  delete <id>       Permanently delete a token"
                    echo ""
                    echo "Options for 'generate':"
                    echo "  --scopes, -s      Comma-separated scopes (default: *)"
                    echo "  --expires, -e     Days until expiration (default: never)"
                    exit 1
                    ;;
            esac
            ;;

        audit)
            local audit_cmd="${2:-summary}"

            # Audit is on by default. Only blocked if explicitly disabled and not force-enabled.
            local _audit_disabled="${LOKI_AUDIT_DISABLED:-false}"
            local _audit_force="${LOKI_ENTERPRISE_AUDIT:-false}"
            if [ "$_audit_force" != "true" ] && [ "$_audit_force" != "1" ]; then
                if [ "$_audit_disabled" = "true" ] || [ "$_audit_disabled" = "1" ]; then
                    echo -e "${YELLOW}Audit logging is disabled${NC}"
                    echo "Remove LOKI_AUDIT_DISABLED or set LOKI_ENTERPRISE_AUDIT=true"
                    exit 1
                fi
            fi

            local audit_dir="${HOME}/.loki/dashboard/audit"

            case "$audit_cmd" in
                summary)
                    echo -e "${BOLD}Audit Summary (Last 7 Days)${NC}"
                    echo ""

                    if [ ! -d "$audit_dir" ]; then
                        echo "  No audit logs found"
                        exit 0
                    fi

                    python3 -c "
import json
import os
from pathlib import Path
from datetime import datetime, timezone, timedelta

audit_dir = Path('$audit_dir')
days = 7
start_date = (datetime.now(timezone.utc) - timedelta(days=days)).strftime('%Y-%m-%d')

entries = []
for log_file in sorted(audit_dir.glob('audit-*.jsonl')):
    if log_file.stem >= f'audit-{start_date}':
        try:
            with open(log_file, 'r') as f:
                for line in f:
                    try:
                        entries.append(json.loads(line.strip()))
                    except json.JSONDecodeError:
                        pass
        except IOError:
            pass

total = len(entries)
success = sum(1 for e in entries if e.get('success', True))
failed = total - success

print(f'Total events: {total}')
print(f'Successful: {success}')
print(f'Failed: {failed}')
print('')

if failed > 0:
    print('Recent failures:')
    failures = [e for e in entries if not e.get('success', True)][-5:]
    for f in failures:
        print(f\"  {f.get('timestamp', '')[:19]} {f.get('action')} {f.get('resource_type')}: {f.get('error', 'unknown')}\")
" 2>/dev/null
                    ;;

                tail)
                    echo -e "${BOLD}Recent Audit Events${NC}"
                    echo ""

                    if [ ! -d "$audit_dir" ]; then
                        echo "  No audit logs found"
                        exit 0
                    fi

                    # Get most recent log file and show last 20 entries
                    local latest_log
                    latest_log=$(ls -t "$audit_dir"/audit-*.jsonl 2>/dev/null | head -1)

                    if [ -z "$latest_log" ]; then
                        echo "  No audit logs found"
                        exit 0
                    fi

                    tail -20 "$latest_log" | python3 -c "
import json
import sys

for line in sys.stdin:
    try:
        e = json.loads(line.strip())
        status = 'OK' if e.get('success', True) else 'FAIL'
        print(f\"[{status}] {e.get('timestamp', '')[:19]} {e.get('action')} {e.get('resource_type')} {e.get('resource_id', '')}\")
    except:
        pass
" 2>/dev/null
                    ;;

                *)
                    echo -e "${RED}Unknown audit command: $audit_cmd${NC}"
                    echo ""
                    echo "Usage: loki enterprise audit <command>"
                    echo ""
                    echo "Commands:"
                    echo "  summary           Show audit summary (last 7 days)"
                    echo "  tail              Show recent audit events"
                    exit 1
                    ;;
            esac
            ;;

        --help|-h|help)
            echo -e "${BOLD}loki enterprise${NC} - Enterprise features (optional)"
            echo ""
            echo "Usage: loki enterprise <command>"
            echo ""
            echo "Commands:"
            echo "  status            Show which enterprise features are enabled"
            echo "  token <cmd>       Manage API tokens (requires LOKI_ENTERPRISE_AUTH=true)"
            echo "  audit <cmd>       Query audit logs (enabled by default)"
            echo ""
            echo "Configure enterprise features:"
            echo "  export LOKI_ENTERPRISE_AUTH=true     # Token authentication"
            echo "  export LOKI_AUDIT_DISABLED=true      # Disable audit logging"
            echo "  export LOKI_ENTERPRISE_AUDIT=true    # Force audit on (legacy)"
            echo ""
            echo "OIDC/SSO (optional, works alongside token auth):"
            echo "  export LOKI_OIDC_ISSUER=https://accounts.google.com"
            echo "  export LOKI_OIDC_CLIENT_ID=your-client-id"
            echo "  export LOKI_OIDC_AUDIENCE=your-audience    # Optional"
            echo ""
            echo "Audit logging is enabled by default. Auth is optional."
            ;;

        *)
            echo -e "${RED}Unknown enterprise command: $subcommand${NC}"
            echo "Run 'loki enterprise help' for usage."
            exit 1
            ;;
    esac
}

# Fetch and display Prometheus metrics from dashboard
cmd_metrics() {
    local subcommand="${1:-}"
    local port="${LOKI_DASHBOARD_PORT:-57374}"
    local host="127.0.0.1"

    case "$subcommand" in
        help|--help|-h)
            echo -e "${BOLD}loki metrics${NC} - Prometheus/OpenMetrics metrics"
            echo ""
            echo "Usage: loki metrics [options]"
            echo ""
            echo "Fetches metrics from the dashboard API in Prometheus/OpenMetrics format."
            echo "The dashboard must be running (loki dashboard start or loki serve)."
            echo ""
            echo "Options:"
            echo "  help    Show this help"
            echo ""
            echo "Environment:"
            echo "  LOKI_DASHBOARD_PORT   Dashboard port (default: 57374)"
            echo ""
            echo "Examples:"
            echo "  loki metrics          # Display all metrics"
            echo "  loki metrics | grep loki_cost_usd   # Filter specific metric"
            ;;
        "")
            # Fetch metrics from dashboard
            local url="http://${host}:${port}/metrics"
            local response
            response=$(curl -sf "$url" 2>/dev/null) || true
            if [ -z "$response" ]; then
                echo -e "${RED}Error: Could not connect to dashboard at ${url}${NC}"
                echo "Make sure the dashboard is running: loki serve"
                exit 1
            fi
            echo "$response"
            ;;
        *)
            echo -e "${RED}Unknown metrics command: $subcommand${NC}"
            echo "Run 'loki metrics help' for usage."
            exit 1
            ;;
    esac
}

# Output shell completion scripts
cmd_completions() {
    local shell="${1:-bash}"
    local skill_dir
    
    # Find the skill directory (where autonomy/loki is located)
    skill_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"
    local completions_dir="$skill_dir/completions"
    
    case "$shell" in
        bash)
            if [ -f "$completions_dir/loki.bash" ]; then
                cat "$completions_dir/loki.bash"
            else
                echo -e "${RED}Error: Bash completion script not found at $completions_dir/loki.bash${NC}" >&2
                exit 1
            fi
            ;;
        zsh)
            if [ -f "$completions_dir/_loki" ]; then
                cat "$completions_dir/_loki"
            else
                echo -e "${RED}Error: Zsh completion script not found at $completions_dir/_loki${NC}" >&2
                exit 1
            fi
            ;;
        *)
            echo -e "${BOLD}Loki Shell Completions${NC}"
            echo ""
            echo "Output shell completion scripts for bash or zsh."
            echo ""
            echo "Usage: loki completions <shell>"
            echo ""
            echo "Shells:"
            echo "  bash    Bash completion script"
            echo "  zsh     Zsh completion script"
            echo ""
            echo "Installation:"
            echo ""
            echo "Bash:"
            echo "  eval \"\$(loki completions bash)\" >> ~/.bashrc"
            echo ""
            echo "Zsh:"
            echo "  eval \"\$(loki completions zsh)\" >> ~/.zshrc"
            echo ""
            exit 1
            ;;
    esac
}

main "$@"
